<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Vue Virtual Dom - Blog(issues)</title><meta property="og:type" content="artical"/><meta property="og:title" content="Vue Virtual Dom"/><meta property="og:image" content="
        https://og-image.vercel.app/Vue Virtual Dom.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fvercel-triangle-black.svg
      "/><meta property="article:published_time" content="2021-04-07T15:13:31Z"/><meta property="article:author" content="xiaotiandada"/><meta name="twitter:card" content="Vue Virtual Dom"/><meta name="twitter:title" content="Vue Virtual Dom"/><meta name="twitter:image" content="
        https://og-image.vercel.app/Vue Virtual Dom.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fvercel-triangle-black.svg
      "/><meta name="next-head-count" content="4"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&amp;display=swap" rel="stylesheet"/><link rel="preload" href="/_next/static/css/b78bfc7021c6877d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b78bfc7021c6877d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-2190439a97dca295.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2aac380799256b7f.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...path%5D-e0b96643230aac68.js" defer=""></script><script src="/_next/static/YPEk3V-eoVeml18YoUSCM/_buildManifest.js" defer=""></script><script src="/_next/static/YPEk3V-eoVeml18YoUSCM/_ssgManifest.js" defer=""></script><script src="/_next/static/YPEk3V-eoVeml18YoUSCM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><div class="container mx-auto mt-24 max-w-2xl px-4 sm:px-0"><div><div class="flex my-8 font-bold"><a href="/">Blog(issues)</a></div></div><div class="mb-8"><div class="text-3xl font-medium">Vue Virtual Dom</div><div class="flex mt-4 items-center gap-2"><img class="w-8 h-8 rounded-full" src="https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d&amp;v=4"/><a target="_blank" href="https://github.com/xiaotiandada">xiaotiandada</a><a class="underline text-sm" target="_blank" href="https://github.com/xiaotiandada/blog/issues/78">View on GitHub</a></div><div class="my-8"><div class="flex gap-4 flex-wrap"></div></div></div><div class="post-body"><p><a href="https://github.com/creeperyang/blog/issues/33">解析 snabbdom 源码，教你实现精简的 Virtual DOM 库</a></p>
<p><a href="https://juejin.cn/post/6844903671906435080#heading-1">snabbdom 源码阅读分析</a></p>
<p><a href="https://juejin.cn/post/6844903831717806087">https://juejin.cn/post/6844903831717806087</a></p>
<p><a href="https://gzg.me/posts/2021/snabbdom_source/">https://gzg.me/posts/2021/snabbdom_source/</a></p>
<p><a href="https://www.cnblogs.com/xuntu/p/6800547.html">https://www.cnblogs.com/xuntu/p/6800547.html</a></p>
<blockquote>
<p>通常情况下，找到两棵任意的树之间最小修改的时间复杂度是 **O(n^3)**，这不可接受。幸好，我们可以对 Virtual DOM 树有这样的假设：</p>
<p>如果 oldVnode 和 vnode 不同（如 type 从 <code>div</code> 变到 <code>p</code>，或者 <code>key</code> 改变），意味着整个 vnode 被替换（因为我们通常不会去跨层移动 vnode ），所以我们没有必要去比较 vnode 的 子 vnode（children） 了。基于这个假设，我们可以 <strong>按照层级分解</strong> 树，这大大简化了复杂度，大到接近 <strong>O(n)</strong> 的复杂度：</p>
<p><img src="https://user-images.githubusercontent.com/8046480/27190439-0a875688-5227-11e7-9015-eb34142de8ce.png" alt=""></p>
<p>此外，对于 children （数组）的比较，因为同层是很可能有移动的，顺
序比较会无法最大化复用已有的 DOM。所以我们通过为每个 vnode 加上 key 来追踪这种顺序变动。</p>
<p><img src="https://user-images.githubusercontent.com/8046480/27191679-28085118-522b-11e7-92e9-fa0ed047f7cd.png" alt=""></p>
</blockquote>
<blockquote>
<ul>
<li>用 js 对象来描述 dom 树结构，然后用这个 js 对象来创建一棵真正的 dom 树，插入到文档中</li>
<li>当状态更新时，将新的 js 对象和旧的 js 对象进行比较，得到两个对象之间的差异</li>
<li>将差异应用到真正的 dom 上</li>
</ul>
</blockquote>
<h3 id="vnode">vnode</h3>
<pre class="language-typescript"><code class="language-typescript">// https://github.com/snabbdom/snabbdom/blob/master/src/vnode.ts
// ...
export type Key = string | number | symbol;

export interface VNode {
  sel: string | undefined;
  data: VNodeData | undefined;
  children: Array<VNode | string> | undefined;
  elm: Node | undefined;
  text: string | undefined;
  key: Key | undefined;
}

export interface VNodeData {
  props?: Props;
  attrs?: Attrs;
  class?: Classes;
  style?: VNodeStyle;
  dataset?: Dataset;
  on?: On;
  attachData?: AttachData;
  hook?: Hooks;
  key?: Key;
  ns?: string; // for SVGs
  fn?: () => VNode; // for thunks
  args?: any[]; // for thunks
  is?: string; // for custom elements v1
  [key: string]: any; // for any other 3rd party module
}

export function vnode(
  sel: string | undefined,
  data: any | undefined,
  children: Array<VNode | string> | undefined,
  text: string | undefined,
  elm: Element | Text | undefined
): VNode {
  const key = data === undefined ? undefined : data.key;
  return { sel, data, children, text, elm, key };
}</code></pre><h3 id="init">init</h3>
<pre class="language-typescript"><code class="language-typescript">// https://github.com/snabbdom/snabbdom/blob/master/src/init.ts
import { Module } from "./modules/module";
import { vnode, VNode } from "./vnode";
import * as is from "./is";
import { htmlDomApi, DOMAPI } from "./htmldomapi";

type NonUndefined<T> = T extends undefined ? never : T;

function isUndef(s: any): boolean {
  return s === undefined;
}
function isDef<A>(s: A): s is NonUndefined<A> {
  return s !== undefined;
}

type VNodeQueue = VNode[];

const emptyNode = vnode("", {}, [], undefined, undefined);

function sameVnode(vnode1: VNode, vnode2: VNode): boolean {
  const isSameKey = vnode1.key === vnode2.key;
  const isSameIs = vnode1.data?.is === vnode2.data?.is;
  const isSameSel = vnode1.sel === vnode2.sel;

  return isSameSel && isSameKey && isSameIs;
}

function isVnode(vnode: any): vnode is VNode {
  return vnode.sel !== undefined;
}

type KeyToIndexMap = { [key: string]: number };

type ArraysOf<T> = {
  [K in keyof T]: Array<T[K]>;
};

type ModuleHooks = ArraysOf<Required<Module>>;

function createKeyToOldIdx(
  children: VNode[],
  beginIdx: number,
  endIdx: number
): KeyToIndexMap {
  const map: KeyToIndexMap = {};
  for (let i = beginIdx; i <= endIdx; ++i) {
    const key = children[i]?.key;
    if (key !== undefined) {
      map[key as string] = i;
    }
  }
  return map;
}

const hooks: Array<keyof Module> = [
  "create",
  "update",
  "remove",
  "destroy",
  "pre",
  "post",
];

export function init(modules: Array<Partial<Module>>, domApi?: DOMAPI) {
  let i: number;
  let j: number;
  // 收集 module in the hook
  const cbs: ModuleHooks = {
    create: [],
    update: [],
    remove: [],
    destroy: [],
    pre: [],
    post: [],
  };
    
  // 如果没有传递 domApi 使用浏览器中和 dom 相关的 api 
  // https://github.com/snabbdom/snabbdom/blob/master/src/htmldomapi.ts
  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    
  // 收集 module in the hook
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      const hook = modules[j][hooks[i]];
      if (hook !== undefined) {
        (cbs[hooks[i]] as any[]).push(hook);
      }
    }
  }

  function emptyNodeAt(elm: Element) {
    const id = elm.id ? "#" + elm.id : "";

    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.
    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring
    // weex https://github.com/vuejs/vue/blob/dev/src/platforms/weex/runtime/node-ops.js
    const classes = elm.getAttribute("class");

    const c = classes ? "." + classes.split(" ").join(".") : "";
    return vnode(
      api.tagName(elm).toLowerCase() + id + c,
      {},
      [],
      undefined,
      elm
    );
  }

  function createRmCb(childElm: Node, listeners: number) {
    return function rmCb() {
      if (--listeners === 0) {
        const parent = api.parentNode(childElm) as Node;
        api.removeChild(parent, childElm);
      }
    };
  }

  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any;
    let data = vnode.data;
    if (data !== undefined) {
      const init = data.hook?.init;
      if (isDef(init)) {
        init(vnode);
        data = vnode.data;
      }
    }
    const children = vnode.children;
    const sel = vnode.sel;
    if (sel === "!") {
      if (isUndef(vnode.text)) {
        vnode.text = "";
      }
      vnode.elm = api.createComment(vnode.text!);
    } else if (sel !== undefined) {
      // Parse selector
      const hashIdx = sel.indexOf("#");
      const dotIdx = sel.indexOf(".", hashIdx);
      const hash = hashIdx > 0 ? hashIdx : sel.length;
      const dot = dotIdx > 0 ? dotIdx : sel.length;
      const tag =
        hashIdx !== -1 || dotIdx !== -1
          ? sel.slice(0, Math.min(hash, dot))
          : sel;
      const elm = (vnode.elm =
        isDef(data) && isDef((i = data.ns))
          ? api.createElementNS(i, tag, data)
          : api.createElement(tag, data));
      if (hash < dot) elm.setAttribute("id", sel.slice(hash + 1, dot));
      if (dotIdx > 0)
        elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          const ch = children[i];
          if (ch != null) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } else if (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      const hook = vnode.data!.hook;
      if (isDef(hook)) {
        hook.create?.(emptyNode, vnode);
        if (hook.insert) {
          insertedVnodeQueue.push(vnode);
        }
      }
    } else {
      vnode.elm = api.createTextNode(vnode.text!);
    }
    return vnode.elm;
  }

  function addVnodes(
    parentElm: Node,
    before: Node | null,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number,
    insertedVnodeQueue: VNodeQueue
  ) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }

  function invokeDestroyHook(vnode: VNode) {
    const data = vnode.data;
    if (data !== undefined) {
      data?.hook?.destroy?.(vnode);
      for (let i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (vnode.children !== undefined) {
        for (let j = 0; j < vnode.children.length; ++j) {
          const child = vnode.children[j];
          if (child != null && typeof child !== "string") {
            invokeDestroyHook(child);
          }
        }
      }
    }
  }

  function removeVnodes(
    parentElm: Node,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number
  ): void {
    for (; startIdx <= endIdx; ++startIdx) {
      let listeners: number;
      let rm: () => void;
      const ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm!, listeners);
          for (let i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          const removeHook = ch?.data?.hook?.remove;
          if (isDef(removeHook)) {
            removeHook(ch, rm);
          } else {
            rm();
          }
        } else {
          // Text node
          api.removeChild(parentElm, ch.elm!);
        }
      }
    }
  }

  function updateChildren(
    parentElm: Node,
    oldCh: VNode[],
    newCh: VNode[],
    insertedVnodeQueue: VNodeQueue
  ) {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let oldKeyToIdx: KeyToIndexMap | undefined;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(
          parentElm,
          oldStartVnode.elm!,
          api.nextSibling(oldEndVnode.elm!)
        );
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (oldKeyToIdx === undefined) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key as string];
        if (isUndef(idxInOld)) {
          // New element
          api.insertBefore(
            parentElm,
            createElm(newStartVnode, insertedVnodeQueue),
            oldStartVnode.elm!
          );
        } else {
          elmToMove = oldCh[idxInOld];
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(
              parentElm,
              createElm(newStartVnode, insertedVnodeQueue),
              oldStartVnode.elm!
            );
          } else {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined as any;
            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(
          parentElm,
          before,
          newCh,
          newStartIdx,
          newEndIdx,
          insertedVnodeQueue
        );
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }

  function patchVnode(
    oldVnode: VNode,
    vnode: VNode,
    insertedVnodeQueue: VNodeQueue
  ) {
    const hook = vnode.data?.hook;
    hook?.prepatch?.(oldVnode, vnode);
    const elm = (vnode.elm = oldVnode.elm)!;
    const oldCh = oldVnode.children as VNode[];
    const ch = vnode.children as VNode[];
    if (oldVnode === vnode) return;
    if (vnode.data !== undefined) {
      for (let i = 0; i < cbs.update.length; ++i)
        cbs.update[i](oldVnode, vnode);
      vnode.data.hook?.update?.(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, "");
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode.text) {
      if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
      api.setTextContent(elm, vnode.text!);
    }
    hook?.postpatch?.(oldVnode, vnode);
  }

  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue = [];
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();

    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    }

    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm!;
      parent = api.parentNode(elm) as Node;

      createElm(vnode, insertedVnodeQueue);

      if (parent !== null) {
        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }

    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
}
</code></pre><h3 id="h">h</h3>
<pre class="language-typescript"><code class="language-typescript">import { vnode, VNode, VNodeData } from "./vnode";
import * as is from "./is";

export type VNodes = VNode[];
export type VNodeChildElement = VNode | string | number | undefined | null;
export type ArrayOrElement<T> = T | T[];
export type VNodeChildren = ArrayOrElement<VNodeChildElement>;

function addNS(
  data: any,
  children: VNodes | undefined,
  sel: string | undefined
): void {
  data.ns = "http://www.w3.org/2000/svg";
  if (sel !== "foreignObject" && children !== undefined) {
    for (let i = 0; i < children.length; ++i) {
      const childData = children[i].data;
      if (childData !== undefined) {
        addNS(childData, children[i].children as VNodes, children[i].sel);
      }
    }
  }
}

export function h(sel: string): VNode;
export function h(sel: string, data: VNodeData | null): VNode;
export function h(sel: string, children: VNodeChildren): VNode;
export function h(
  sel: string,
  data: VNodeData | null,
  children: VNodeChildren
): VNode;
export function h(sel: any, b?: any, c?: any): VNode {
  let data: VNodeData = {};
  let children: any;
  let text: any;
  let i: number;
  // c 不为空 可能是 [] / string
  if (c !== undefined) {
    // b 不为空 有 {} options (认为是 VNodeData)
    if (b !== null) {
      data = b;
    }
    // 如果 c 是 []
    if (is.array(c)) {
      children = c;
    } else if (is.primitive(c)) { // c 是 string / number 应该认为是 text node
      text = c;
    } else if (c && c.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ c ]
      children = [c];
    }
  } else if (b !== undefined && b !== null) { // 如果是 b 不为空
    // 如果是 array 说明是 VNodeChildren
    if (is.array(b)) {
      children = b;
    } else if (is.primitive(b)) { // 如果是 string/number 应该认为是 text node
      text = b;
    } else if (b && b.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ b ]
      children = [b];
    } else { // 认为 b 是 VNodeData
      data = b;
    }
  }
  // 如果存在 children
  if (children !== undefined) {
    for (i = 0; i < children.length; ++i) {
      // 如果每个 children 是 string/number 转换成 vnode
      if (is.primitive(children[i]))
        children[i] = vnode(
          undefined,
          undefined,
          undefined,
          children[i],
          undefined
        );
    }
  }
  // 如果是 svg 添加 namespace
  if (
    sel[0] === "s" &&
    sel[1] === "v" &&
    sel[2] === "g" &&
    (sel.length === 3 || sel[3] === "." || sel[3] === "#")
  ) {
    addNS(data, children, sel);
  }
  return vnode(sel, data, children, text, undefined);
}</code></pre><h3 id="patch">patch</h3>
<pre class="language-typescript"><code class="language-typescript">// 调用 init 返回 patch  

  function emptyNodeAt(elm: Element) {
    const id = elm.id ? "#" + elm.id : "";

    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.
    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring
    const classes = elm.getAttribute("class");

    const c = classes ? "." + classes.split(" ").join(".") : "";
    // document.querySelector('div').tagName => DIV
    // div#id.classa.classb / div#id / div.class / div
    return vnode(
      api.tagName(elm).toLowerCase() + id + c,
      {},
      [],
      undefined,
      elm
    );
  }

return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue = [];
      // 调用 module 中的 pre hook 
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();
        
      // 如果 oldVnode 是 Element 转换为空的 vnode
    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    }
            
       // > 如果相同，调用 patchVnode，如果不相同，会调用 createElm 来创建一个新的 dom 节点，然后如果存在父节点，便将其插入到 dom 上，然后移除旧的 dom 节点来完成更新。
  
      // oldVnode vnode sel key is 相同
    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm!;
      // ele parentNode
      parent = api.parentNode(elm) as Node;
            // 创建
      createElm(vnode, insertedVnodeQueue);
            
      // 有父节点
      if (parent !== null) {
        // insert dom
        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));
        // remove vnode
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }
        
  // 调用元素上的 insert hook，insert  hook 在 module 上不支持
    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);
    }
      // 调用 module post hook
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };</code></pre><blockquote>
<p>The following hooks are available for modules: <code>pre</code>, <code>create</code>, <code>update</code>, <code>destroy</code>, <code>remove</code>, <code>post</code></p>
<p>The following hooks are available in the <code>hook</code> property of individual elements: <code>init</code>, <code>create</code>, <code>insert</code>, <code>prepatch</code>, <code>update</code>, <code>postpatch</code>, <code>destroy</code>, <code>remove</code>.</p>
</blockquote>
<h3 id="createelm">createElm</h3>
<pre class="language-typescript"><code class="language-typescript">  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any;
    let data = vnode.data;
    // 调用元素的 init hook
    if (data !== undefined) {
      const init = data.hook?.init;
      if (isDef(init)) {
        init(vnode);
        data = vnode.data;
      }
    }
    const children = vnode.children;
    
    // 创建注释节点
    const sel = vnode.sel;
    if (sel === "!") {
      if (isUndef(vnode.text)) {
        vnode.text = "";
      }
      vnode.elm = api.createComment(vnode.text!);
    } else if (sel !== undefined) {
      // Parse selector
      const hashIdx = sel.indexOf("#");
      const dotIdx = sel.indexOf(".", hashIdx);
      // div#box
      const hash = hashIdx > 0 ? hashIdx : sel.length;
      // div.boxclass
      const dot = dotIdx > 0 ? dotIdx : sel.length;
      const tag =
        hashIdx !== -1 || dotIdx !== -1
          ? sel.slice(0, Math.min(hash, dot))
          : sel;
      const elm = (vnode.elm =
        isDef(data) && isDef((i = data.ns))
          ? api.createElementNS(i, tag, data)
          : api.createElement(tag, data));
      if (hash < dot) elm.setAttribute("id", sel.slice(hash + 1, dot));
      if (dotIdx > 0)
        elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
      // 调用 module 的 create hook
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      // 挂在子节点
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          const ch = children[i];
          if (ch != null) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } else if (is.primitive(vnode.text)) {
        // 插入 文本节点
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      // 执行 vnode data hook
      const hook = vnode.data!.hook;
      if (isDef(hook)) {
        // 执行 hook create
        hook.create?.(emptyNode, vnode);
        if (hook.insert) {
          // insert hook 存储起来 等 dom 插入后才会调用，这里用个数组来保存能避免调用时再次对 vnode 树做遍历
          insertedVnodeQueue.push(vnode);
        }
      }
    } else {
      // 文本节点
      vnode.elm = api.createTextNode(vnode.text!);
    }
    return vnode.elm;
  }</code></pre><h3 id="patchvnode">patchVnode</h3>
<pre class="language-typescript"><code class="language-typescript">function patchVnode(
    oldVnode: VNode,
    vnode: VNode,
    insertedVnodeQueue: VNodeQueue
  ) {
    const hook = vnode.data?.hook;
    // 执行 prepatch hook
    hook?.prepatch?.(oldVnode, vnode);
    const elm = (vnode.elm = oldVnode.elm)!;
    const oldCh = oldVnode.children as VNode[];
    const ch = vnode.children as VNode[];
     // 新 旧 vnode 相同
    if (oldVnode === vnode) return;
    // 执行 cbs update hook，vnode update hook
    if (vnode.data !== undefined) {
      for (let i = 0; i < cbs.update.length; ++i)
        cbs.update[i](oldVnode, vnode);
      vnode.data.hook?.update?.(oldVnode, vnode);
    }
    // 是没有定义的
    if (isUndef(vnode.text)) {
      // 均存在 children 且不相同，调用 updateChildren
    
      // 定义过 children
      if (isDef(oldCh) && isDef(ch)) {
        // old children 不等于 new children
        // 更新 updateChildren
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) { // 只定义了 new children
        // 新 vnode 存在 children，旧 vnode 不存在 children，如果旧 vnode 存在 text 先清空，然后调用 addVnodes
        
        // 如果是 text，设置内容
        if (isDef(oldVnode.text)) api.setTextContent(elm, "");
        // 添加 vnode
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) { // 只定义 old children
        // 新 vnode 不存在 children，旧 vnode 存在 children，调用 removeVnodes 移除 children
        
        // 移除 vnode
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) { // 只定义了 old vnode text
        // 设置内容
        api.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode.text) { // old vnode text 和 new vnode text 不一样
      // 均不存在 children，新 vnode 不存在 text，移除旧 vnode 的 text
      
      // 如果定义了 old children
      if (isDef(oldCh)) {
        // 移除
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
      // 均存在 text，更新 text
      
      // 设置新内容
      api.setTextContent(elm, vnode.text!);
    }
    // 执行 postpatch hook
    hook?.postpatch?.(oldVnode, vnode);
  }</code></pre><h3 id="updatechildren">updateChildren</h3>
<pre class="language-typescript"><code class="language-typescript">  function updateChildren(
    parentElm: Node,
    oldCh: VNode[],
    newCh: VNode[],
    insertedVnodeQueue: VNodeQueue
  ) {
    let oldStartIdx = 0; // 旧 头 索引
    let newStartIdx = 0; // 新 头 索引
    let oldEndIdx = oldCh.length - 1; // 旧 尾 索引
    let oldStartVnode = oldCh[0]; // 旧 头 Vnode
    let oldEndVnode = oldCh[oldEndIdx]; // 旧 尾 Vnode
    let newEndIdx = newCh.length - 1; // 新 尾 索引
    let newStartVnode = newCh[0]; // 新 头 Vnode
    let newEndVnode = newCh[newEndIdx]; // 新 尾 Vnode
    let oldKeyToIdx: KeyToIndexMap | undefined;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    // 循环 从 头 到 尾 处理（新/旧）
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      // 如果 头尾（新/旧）其中有为 null 重新赋值，并且为元素数组中 添加/减少 一位
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];

        // 如果相同 对比 新/旧 内容变化然后更新 DOM
        // 新/旧 头Vnode 赋值
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];

        // 节点移动到右边 更新 DOM
        // 把更新的内容移动插入到旧节点最后
        // 旧头索引 ++
        // 新尾索引 --
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(
          parentElm,
          oldStartVnode.elm!,
          api.nextSibling(oldEndVnode.elm!)
        );
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];

        // 节点移动到左边 更新 DOM
        // 把更新的内容移动插入到旧节点最前
        // 旧尾 --
        // 新头 ++
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];


        // 如果不是以上情况
        // 开始节点是一个新节点
        // 如果没有 key，创建 DOM 插入到前方
        // 如果有 key，判断 sel 是否相同，如果不同创建 DOM 如果相同则代表是相同节点
      } else {

        // 方便通过新节点的key找到旧节点数组的索引
        if (oldKeyToIdx === undefined) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        // 用新节点的key 找到老节点的索引
        idxInOld = oldKeyToIdx[newStartVnode.key as string];

        // 如果是新节点
        if (isUndef(idxInOld)) {
          // New element
          api.insertBefore(
            parentElm,
            createElm(newStartVnode, insertedVnodeQueue),
            oldStartVnode.elm!
          );
        } else {
          // 旧节点
          // 取出旧节点
          elmToMove = oldCh[idxInOld];
          // 新元素 直接创建一个新的插入
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(
              parentElm,
              createElm(newStartVnode, insertedVnodeQueue),
              oldStartVnode.elm!
            );
          } else {
            // 没有修改过 更新内部 DOM
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            // 把旧节点相应位置的元素设置为undefined
            oldCh[idxInOld] = undefined as any;
            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);
          }
        }
        // 插入完成后，索引增加
        newStartVnode = newCh[++newStartIdx];
      }
    }

    // 老节点 或 新节点遍历完成
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(
          parentElm,
          before,
          newCh,
          newStartIdx,
          newEndIdx,
          insertedVnodeQueue
        );
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }</code></pre><h3 id="addvnodes">addVnodes</h3>
<pre class="language-typescript"><code class="language-typescript">  function addVnodes(
    parentElm: Node,
    before: Node | null,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number,
    insertedVnodeQueue: VNodeQueue
  ) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }</code></pre><h3 id="removevnodes">removeVnodes</h3>
<pre class="language-typescript"><code class="language-typescript">
  function removeVnodes(
    parentElm: Node,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number
  ): void {
    for (; startIdx <= endIdx; ++startIdx) {
      let listeners: number;
      let rm: () => void;
      const ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          // ˙执行 ch data destroy hook
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm!, listeners);
          // 调用 module 中是 remove hook
          for (let i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
           // 调用 vnode 的 remove hook
          const removeHook = ch?.data?.hook?.remove;
          if (isDef(removeHook)) {
            removeHook(ch, rm);
          } else {
            rm();
          }
        } else {
          // Text node
          api.removeChild(parentElm, ch.elm!);
        }
      }
    }
  }

// 调用 destroy hook
function invokeDestroyHook(vnode: VNode) {
  const data = vnode.data;
  if (data !== undefined) {
    data?.hook?.destroy?.(vnode);
    for (let i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
    if (vnode.children !== undefined) {
      for (let j = 0; j < vnode.children.length; ++j) {
        const child = vnode.children[j];
        if (child != null && typeof child !== "string") {
          invokeDestroyHook(child);
        }
      }
    }
  }
}


function createRmCb(childElm: Node, listeners: number) {
  return function rmCb() {
    if (--listeners === 0) {
      const parent = api.parentNode(childElm) as Node;
      api.removeChild(parent, childElm);
    }
  };
}</code></pre><h3 id="createelm-1">createElm</h3>
<pre class="language-typescript"><code class="language-typescript">  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any;
    let data = vnode.data;
    if (data !== undefined) {
      // 调用 init hook
      const init = data.hook?.init;
      if (isDef(init)) {
        init(vnode);
        data = vnode.data;
      }
    }
    const children = vnode.children;
    const sel = vnode.sel;
    if (sel === "!") { // 注释
      if (isUndef(vnode.text)) {
        vnode.text = "";
      }
      vnode.elm = api.createComment(vnode.text!);
    } else if (sel !== undefined) {
      // Parse selector
      const hashIdx = sel.indexOf("#");
      const dotIdx = sel.indexOf(".", hashIdx);
      const hash = hashIdx > 0 ? hashIdx : sel.length;
      const dot = dotIdx > 0 ? dotIdx : sel.length;
      const tag =
        hashIdx !== -1 || dotIdx !== -1
          ? sel.slice(0, Math.min(hash, dot))
          : sel;
      const elm = (vnode.elm =
        isDef(data) && isDef((i = data.ns))
          ? api.createElementNS(i, tag, data)
          : api.createElement(tag, data));
      if (hash < dot) elm.setAttribute("id", sel.slice(hash + 1, dot));
      if (dotIdx > 0)
        elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          const ch = children[i];
          if (ch != null) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } else if (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      // 调用 create hook
      const hook = vnode.data!.hook;
      if (isDef(hook)) {
        hook.create?.(emptyNode, vnode);
        if (hook.insert) {
          insertedVnodeQueue.push(vnode);
        }
      }
    } else {
      vnode.elm = api.createTextNode(vnode.text!);
    }
    return vnode.elm;
  }</code></pre><h3 id="thunk">thunk</h3>
<pre class="language-typescript"><code class="language-typescript">export interface ThunkData extends VNodeData {
  fn: () => VNode;
  args: any[];
}

export interface Thunk extends VNode {
  data: ThunkData;
}

export interface ThunkFn {
  (sel: string, fn: (...args: any[]) => any, args: any[]): Thunk;
  (sel: string, key: any, fn: (...args: any[]) => any, args: any[]): Thunk;
}

// thunk  fn 、 args 属性保存到 vnode 上，在 prepatch 时需要进行比较
// 将 vnode 上的数据拷贝到 thunk 上， patchVnode 中判断，相同会结束 patchVnode
function copyToThunk(vnode: VNode, thunk: VNode): void {
  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;
  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;
  thunk.data = vnode.data;
  thunk.children = vnode.children;
  thunk.text = vnode.text;
  thunk.elm = vnode.elm;
}

function init(thunk: VNode): void {
  const cur = thunk.data as VNodeData;
  const vnode = (cur.fn as any)(...cur.args!);
  copyToThunk(vnode, thunk);
}

function prepatch(oldVnode: VNode, thunk: VNode): void {
  let i: number;
  const old = oldVnode.data as VNodeData;
  const cur = thunk.data as VNodeData;
  const oldArgs = old.args;
  const args = cur.args;
  //  如果 fn 不同或 args 长度不同，说明发生了变化，调用 fn 生成新的 vnode 并返回
  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {
    copyToThunk((cur.fn as any)(...args!), thunk);
    return;
  }
  // 如果每个参数发生变化，逻辑同上
  for (i = 0; i < (args as any).length; ++i) {
    if ((oldArgs as any)[i] !== (args as any)[i]) {
      copyToThunk((cur.fn as any)(...args!), thunk);
      return;
    }
  }
  copyToThunk(oldVnode, thunk);
}
// 使用 h 返回 vnode
// 添加 init prepatch hook
export const thunk = function thunk(
  sel: string,
  key?: any,
  fn?: any,
  args?: any
): VNode {
  if (args === undefined) {
    args = fn;
    fn = key;
    key = undefined;
  }
  return h(sel, {
    key: key,
    hook: { init, prepatch },
    fn: fn,
    args: args,
  });
} as ThunkFn;
</code></pre></div><hr class="my-12"/><div class="font-sans"><div class="mb-12"><a target="_blank" href="https://github.com/xiaotiandada/blog/issues/78" class="font-medium border border-gray-700 hover:bg-gray-700 hover:text-gray-100 transition-all text-gray-700 text-sm rounded px-4 py-2">Add comment</a></div></div><div class="my-12"><div class="text-sm">Powered by <a class="underline" target="_blank" href="https://github.com/djyde/sairin">Sairin</a></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"MDU6SXNzdWU4NTI1MTQ2OTk=","url":"https://github.com/xiaotiandada/blog/issues/78","title":"Vue Virtual Dom","updatedAt":"2022-04-05T17:33:16Z","createdAt":"2021-04-07T15:13:31Z","body":"[解析 snabbdom 源码，教你实现精简的 Virtual DOM 库](https://github.com/creeperyang/blog/issues/33)\r\n\r\n[snabbdom 源码阅读分析](https://juejin.cn/post/6844903671906435080#heading-1)\r\n\r\nhttps://juejin.cn/post/6844903831717806087\r\n\r\nhttps://gzg.me/posts/2021/snabbdom_source/\r\n\r\nhttps://www.cnblogs.com/xuntu/p/6800547.html\r\n\r\n\u003e通常情况下，找到两棵任意的树之间最小修改的时间复杂度是 **O(n^3)**，这不可接受。幸好，我们可以对 Virtual DOM 树有这样的假设：\r\n\u003e\r\n\u003e如果 oldVnode 和 vnode 不同（如 type 从 `div` 变到 `p`，或者 `key` 改变），意味着整个 vnode 被替换（因为我们通常不会去跨层移动 vnode ），所以我们没有必要去比较 vnode 的 子 vnode（children） 了。基于这个假设，我们可以 **按照层级分解** 树，这大大简化了复杂度，大到接近 **O(n)** 的复杂度：\r\n\u003e\r\n\u003e![](https://user-images.githubusercontent.com/8046480/27190439-0a875688-5227-11e7-9015-eb34142de8ce.png)\r\n\u003e\r\n\u003e此外，对于 children （数组）的比较，因为同层是很可能有移动的，顺\r\n\u003e序比较会无法最大化复用已有的 DOM。所以我们通过为每个 vnode 加上 key 来追踪这种顺序变动。\r\n\u003e\r\n\u003e![](https://user-images.githubusercontent.com/8046480/27191679-28085118-522b-11e7-92e9-fa0ed047f7cd.png)\r\n\u003e\r\n\u003e\r\n\r\n\r\n\r\n\u003e- 用 js 对象来描述 dom 树结构，然后用这个 js 对象来创建一棵真正的 dom 树，插入到文档中\r\n\u003e- 当状态更新时，将新的 js 对象和旧的 js 对象进行比较，得到两个对象之间的差异\r\n\u003e- 将差异应用到真正的 dom 上\r\n\r\n\r\n\r\n### vnode\r\n\r\n```typescript\r\n// https://github.com/snabbdom/snabbdom/blob/master/src/vnode.ts\r\n// ...\r\nexport type Key = string | number | symbol;\r\n\r\nexport interface VNode {\r\n  sel: string | undefined;\r\n  data: VNodeData | undefined;\r\n  children: Array\u003cVNode | string\u003e | undefined;\r\n  elm: Node | undefined;\r\n  text: string | undefined;\r\n  key: Key | undefined;\r\n}\r\n\r\nexport interface VNodeData {\r\n  props?: Props;\r\n  attrs?: Attrs;\r\n  class?: Classes;\r\n  style?: VNodeStyle;\r\n  dataset?: Dataset;\r\n  on?: On;\r\n  attachData?: AttachData;\r\n  hook?: Hooks;\r\n  key?: Key;\r\n  ns?: string; // for SVGs\r\n  fn?: () =\u003e VNode; // for thunks\r\n  args?: any[]; // for thunks\r\n  is?: string; // for custom elements v1\r\n  [key: string]: any; // for any other 3rd party module\r\n}\r\n\r\nexport function vnode(\r\n  sel: string | undefined,\r\n  data: any | undefined,\r\n  children: Array\u003cVNode | string\u003e | undefined,\r\n  text: string | undefined,\r\n  elm: Element | Text | undefined\r\n): VNode {\r\n  const key = data === undefined ? undefined : data.key;\r\n  return { sel, data, children, text, elm, key };\r\n}\r\n```\r\n\r\n### init\r\n\r\n```typescript\r\n// https://github.com/snabbdom/snabbdom/blob/master/src/init.ts\r\nimport { Module } from \"./modules/module\";\r\nimport { vnode, VNode } from \"./vnode\";\r\nimport * as is from \"./is\";\r\nimport { htmlDomApi, DOMAPI } from \"./htmldomapi\";\r\n\r\ntype NonUndefined\u003cT\u003e = T extends undefined ? never : T;\r\n\r\nfunction isUndef(s: any): boolean {\r\n  return s === undefined;\r\n}\r\nfunction isDef\u003cA\u003e(s: A): s is NonUndefined\u003cA\u003e {\r\n  return s !== undefined;\r\n}\r\n\r\ntype VNodeQueue = VNode[];\r\n\r\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined);\r\n\r\nfunction sameVnode(vnode1: VNode, vnode2: VNode): boolean {\r\n  const isSameKey = vnode1.key === vnode2.key;\r\n  const isSameIs = vnode1.data?.is === vnode2.data?.is;\r\n  const isSameSel = vnode1.sel === vnode2.sel;\r\n\r\n  return isSameSel \u0026\u0026 isSameKey \u0026\u0026 isSameIs;\r\n}\r\n\r\nfunction isVnode(vnode: any): vnode is VNode {\r\n  return vnode.sel !== undefined;\r\n}\r\n\r\ntype KeyToIndexMap = { [key: string]: number };\r\n\r\ntype ArraysOf\u003cT\u003e = {\r\n  [K in keyof T]: Array\u003cT[K]\u003e;\r\n};\r\n\r\ntype ModuleHooks = ArraysOf\u003cRequired\u003cModule\u003e\u003e;\r\n\r\nfunction createKeyToOldIdx(\r\n  children: VNode[],\r\n  beginIdx: number,\r\n  endIdx: number\r\n): KeyToIndexMap {\r\n  const map: KeyToIndexMap = {};\r\n  for (let i = beginIdx; i \u003c= endIdx; ++i) {\r\n    const key = children[i]?.key;\r\n    if (key !== undefined) {\r\n      map[key as string] = i;\r\n    }\r\n  }\r\n  return map;\r\n}\r\n\r\nconst hooks: Array\u003ckeyof Module\u003e = [\r\n  \"create\",\r\n  \"update\",\r\n  \"remove\",\r\n  \"destroy\",\r\n  \"pre\",\r\n  \"post\",\r\n];\r\n\r\nexport function init(modules: Array\u003cPartial\u003cModule\u003e\u003e, domApi?: DOMAPI) {\r\n  let i: number;\r\n  let j: number;\r\n  // 收集 module in the hook\r\n  const cbs: ModuleHooks = {\r\n    create: [],\r\n    update: [],\r\n    remove: [],\r\n    destroy: [],\r\n    pre: [],\r\n    post: [],\r\n  };\r\n\t\r\n  // 如果没有传递 domApi 使用浏览器中和 dom 相关的 api \r\n  // https://github.com/snabbdom/snabbdom/blob/master/src/htmldomapi.ts\r\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;\r\n\t\r\n  // 收集 module in the hook\r\n  for (i = 0; i \u003c hooks.length; ++i) {\r\n    cbs[hooks[i]] = [];\r\n    for (j = 0; j \u003c modules.length; ++j) {\r\n      const hook = modules[j][hooks[i]];\r\n      if (hook !== undefined) {\r\n        (cbs[hooks[i]] as any[]).push(hook);\r\n      }\r\n    }\r\n  }\r\n\r\n  function emptyNodeAt(elm: Element) {\r\n    const id = elm.id ? \"#\" + elm.id : \"\";\r\n\r\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\r\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\r\n    // weex https://github.com/vuejs/vue/blob/dev/src/platforms/weex/runtime/node-ops.js\r\n    const classes = elm.getAttribute(\"class\");\r\n\r\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\r\n    return vnode(\r\n      api.tagName(elm).toLowerCase() + id + c,\r\n      {},\r\n      [],\r\n      undefined,\r\n      elm\r\n    );\r\n  }\r\n\r\n  function createRmCb(childElm: Node, listeners: number) {\r\n    return function rmCb() {\r\n      if (--listeners === 0) {\r\n        const parent = api.parentNode(childElm) as Node;\r\n        api.removeChild(parent, childElm);\r\n      }\r\n    };\r\n  }\r\n\r\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\r\n    let i: any;\r\n    let data = vnode.data;\r\n    if (data !== undefined) {\r\n      const init = data.hook?.init;\r\n      if (isDef(init)) {\r\n        init(vnode);\r\n        data = vnode.data;\r\n      }\r\n    }\r\n    const children = vnode.children;\r\n    const sel = vnode.sel;\r\n    if (sel === \"!\") {\r\n      if (isUndef(vnode.text)) {\r\n        vnode.text = \"\";\r\n      }\r\n      vnode.elm = api.createComment(vnode.text!);\r\n    } else if (sel !== undefined) {\r\n      // Parse selector\r\n      const hashIdx = sel.indexOf(\"#\");\r\n      const dotIdx = sel.indexOf(\".\", hashIdx);\r\n      const hash = hashIdx \u003e 0 ? hashIdx : sel.length;\r\n      const dot = dotIdx \u003e 0 ? dotIdx : sel.length;\r\n      const tag =\r\n        hashIdx !== -1 || dotIdx !== -1\r\n          ? sel.slice(0, Math.min(hash, dot))\r\n          : sel;\r\n      const elm = (vnode.elm =\r\n        isDef(data) \u0026\u0026 isDef((i = data.ns))\r\n          ? api.createElementNS(i, tag, data)\r\n          : api.createElement(tag, data));\r\n      if (hash \u003c dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\r\n      if (dotIdx \u003e 0)\r\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\r\n      for (i = 0; i \u003c cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\r\n      if (is.array(children)) {\r\n        for (i = 0; i \u003c children.length; ++i) {\r\n          const ch = children[i];\r\n          if (ch != null) {\r\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\r\n          }\r\n        }\r\n      } else if (is.primitive(vnode.text)) {\r\n        api.appendChild(elm, api.createTextNode(vnode.text));\r\n      }\r\n      const hook = vnode.data!.hook;\r\n      if (isDef(hook)) {\r\n        hook.create?.(emptyNode, vnode);\r\n        if (hook.insert) {\r\n          insertedVnodeQueue.push(vnode);\r\n        }\r\n      }\r\n    } else {\r\n      vnode.elm = api.createTextNode(vnode.text!);\r\n    }\r\n    return vnode.elm;\r\n  }\r\n\r\n  function addVnodes(\r\n    parentElm: Node,\r\n    before: Node | null,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    for (; startIdx \u003c= endIdx; ++startIdx) {\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\r\n      }\r\n    }\r\n  }\r\n\r\n  function invokeDestroyHook(vnode: VNode) {\r\n    const data = vnode.data;\r\n    if (data !== undefined) {\r\n      data?.hook?.destroy?.(vnode);\r\n      for (let i = 0; i \u003c cbs.destroy.length; ++i) cbs.destroy[i](vnode);\r\n      if (vnode.children !== undefined) {\r\n        for (let j = 0; j \u003c vnode.children.length; ++j) {\r\n          const child = vnode.children[j];\r\n          if (child != null \u0026\u0026 typeof child !== \"string\") {\r\n            invokeDestroyHook(child);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeVnodes(\r\n    parentElm: Node,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number\r\n  ): void {\r\n    for (; startIdx \u003c= endIdx; ++startIdx) {\r\n      let listeners: number;\r\n      let rm: () =\u003e void;\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        if (isDef(ch.sel)) {\r\n          invokeDestroyHook(ch);\r\n          listeners = cbs.remove.length + 1;\r\n          rm = createRmCb(ch.elm!, listeners);\r\n          for (let i = 0; i \u003c cbs.remove.length; ++i) cbs.remove[i](ch, rm);\r\n          const removeHook = ch?.data?.hook?.remove;\r\n          if (isDef(removeHook)) {\r\n            removeHook(ch, rm);\r\n          } else {\r\n            rm();\r\n          }\r\n        } else {\r\n          // Text node\r\n          api.removeChild(parentElm, ch.elm!);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateChildren(\r\n    parentElm: Node,\r\n    oldCh: VNode[],\r\n    newCh: VNode[],\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    let oldStartIdx = 0;\r\n    let newStartIdx = 0;\r\n    let oldEndIdx = oldCh.length - 1;\r\n    let oldStartVnode = oldCh[0];\r\n    let oldEndVnode = oldCh[oldEndIdx];\r\n    let newEndIdx = newCh.length - 1;\r\n    let newStartVnode = newCh[0];\r\n    let newEndVnode = newCh[newEndIdx];\r\n    let oldKeyToIdx: KeyToIndexMap | undefined;\r\n    let idxInOld: number;\r\n    let elmToMove: VNode;\r\n    let before: any;\r\n\r\n    while (oldStartIdx \u003c= oldEndIdx \u0026\u0026 newStartIdx \u003c= newEndIdx) {\r\n      if (oldStartVnode == null) {\r\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\r\n      } else if (oldEndVnode == null) {\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n      } else if (newStartVnode == null) {\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (newEndVnode == null) {\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n        // Vnode moved right\r\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\r\n        api.insertBefore(\r\n          parentElm,\r\n          oldStartVnode.elm!,\r\n          api.nextSibling(oldEndVnode.elm!)\r\n        );\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n        // Vnode moved left\r\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\r\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else {\r\n        if (oldKeyToIdx === undefined) {\r\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\r\n        if (isUndef(idxInOld)) {\r\n          // New element\r\n          api.insertBefore(\r\n            parentElm,\r\n            createElm(newStartVnode, insertedVnodeQueue),\r\n            oldStartVnode.elm!\r\n          );\r\n        } else {\r\n          elmToMove = oldCh[idxInOld];\r\n          if (elmToMove.sel !== newStartVnode.sel) {\r\n            api.insertBefore(\r\n              parentElm,\r\n              createElm(newStartVnode, insertedVnodeQueue),\r\n              oldStartVnode.elm!\r\n            );\r\n          } else {\r\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\r\n            oldCh[idxInOld] = undefined as any;\r\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\r\n          }\r\n        }\r\n        newStartVnode = newCh[++newStartIdx];\r\n      }\r\n    }\r\n    if (oldStartIdx \u003c= oldEndIdx || newStartIdx \u003c= newEndIdx) {\r\n      if (oldStartIdx \u003e oldEndIdx) {\r\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\r\n        addVnodes(\r\n          parentElm,\r\n          before,\r\n          newCh,\r\n          newStartIdx,\r\n          newEndIdx,\r\n          insertedVnodeQueue\r\n        );\r\n      } else {\r\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\r\n      }\r\n    }\r\n  }\r\n\r\n  function patchVnode(\r\n    oldVnode: VNode,\r\n    vnode: VNode,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    const hook = vnode.data?.hook;\r\n    hook?.prepatch?.(oldVnode, vnode);\r\n    const elm = (vnode.elm = oldVnode.elm)!;\r\n    const oldCh = oldVnode.children as VNode[];\r\n    const ch = vnode.children as VNode[];\r\n    if (oldVnode === vnode) return;\r\n    if (vnode.data !== undefined) {\r\n      for (let i = 0; i \u003c cbs.update.length; ++i)\r\n        cbs.update[i](oldVnode, vnode);\r\n      vnode.data.hook?.update?.(oldVnode, vnode);\r\n    }\r\n    if (isUndef(vnode.text)) {\r\n      if (isDef(oldCh) \u0026\u0026 isDef(ch)) {\r\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\r\n      } else if (isDef(ch)) {\r\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\r\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n      } else if (isDef(oldCh)) {\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      } else if (isDef(oldVnode.text)) {\r\n        api.setTextContent(elm, \"\");\r\n      }\r\n    } else if (oldVnode.text !== vnode.text) {\r\n      if (isDef(oldCh)) {\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      }\r\n      api.setTextContent(elm, vnode.text!);\r\n    }\r\n    hook?.postpatch?.(oldVnode, vnode);\r\n  }\r\n\r\n  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\r\n    let i: number, elm: Node, parent: Node;\r\n    const insertedVnodeQueue: VNodeQueue = [];\r\n    for (i = 0; i \u003c cbs.pre.length; ++i) cbs.pre[i]();\r\n\r\n    if (!isVnode(oldVnode)) {\r\n      oldVnode = emptyNodeAt(oldVnode);\r\n    }\r\n\r\n    if (sameVnode(oldVnode, vnode)) {\r\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\r\n    } else {\r\n      elm = oldVnode.elm!;\r\n      parent = api.parentNode(elm) as Node;\r\n\r\n      createElm(vnode, insertedVnodeQueue);\r\n\r\n      if (parent !== null) {\r\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\r\n        removeVnodes(parent, [oldVnode], 0, 0);\r\n      }\r\n    }\r\n\r\n    for (i = 0; i \u003c insertedVnodeQueue.length; ++i) {\r\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\r\n    }\r\n    for (i = 0; i \u003c cbs.post.length; ++i) cbs.post[i]();\r\n    return vnode;\r\n  };\r\n}\r\n\r\n```\r\n\r\n### h\r\n\r\n```typescript\r\nimport { vnode, VNode, VNodeData } from \"./vnode\";\r\nimport * as is from \"./is\";\r\n\r\nexport type VNodes = VNode[];\r\nexport type VNodeChildElement = VNode | string | number | undefined | null;\r\nexport type ArrayOrElement\u003cT\u003e = T | T[];\r\nexport type VNodeChildren = ArrayOrElement\u003cVNodeChildElement\u003e;\r\n\r\nfunction addNS(\r\n  data: any,\r\n  children: VNodes | undefined,\r\n  sel: string | undefined\r\n): void {\r\n  data.ns = \"http://www.w3.org/2000/svg\";\r\n  if (sel !== \"foreignObject\" \u0026\u0026 children !== undefined) {\r\n    for (let i = 0; i \u003c children.length; ++i) {\r\n      const childData = children[i].data;\r\n      if (childData !== undefined) {\r\n        addNS(childData, children[i].children as VNodes, children[i].sel);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function h(sel: string): VNode;\r\nexport function h(sel: string, data: VNodeData | null): VNode;\r\nexport function h(sel: string, children: VNodeChildren): VNode;\r\nexport function h(\r\n  sel: string,\r\n  data: VNodeData | null,\r\n  children: VNodeChildren\r\n): VNode;\r\nexport function h(sel: any, b?: any, c?: any): VNode {\r\n  let data: VNodeData = {};\r\n  let children: any;\r\n  let text: any;\r\n  let i: number;\r\n  // c 不为空 可能是 [] / string\r\n  if (c !== undefined) {\r\n    // b 不为空 有 {} options (认为是 VNodeData)\r\n    if (b !== null) {\r\n      data = b;\r\n    }\r\n    // 如果 c 是 []\r\n    if (is.array(c)) {\r\n      children = c;\r\n    } else if (is.primitive(c)) { // c 是 string / number 应该认为是 text node\r\n      text = c;\r\n    } else if (c \u0026\u0026 c.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ c ]\r\n      children = [c];\r\n    }\r\n  } else if (b !== undefined \u0026\u0026 b !== null) { // 如果是 b 不为空\r\n    // 如果是 array 说明是 VNodeChildren\r\n    if (is.array(b)) {\r\n      children = b;\r\n    } else if (is.primitive(b)) { // 如果是 string/number 应该认为是 text node\r\n      text = b;\r\n    } else if (b \u0026\u0026 b.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ b ]\r\n      children = [b];\r\n    } else { // 认为 b 是 VNodeData\r\n      data = b;\r\n    }\r\n  }\r\n  // 如果存在 children\r\n  if (children !== undefined) {\r\n    for (i = 0; i \u003c children.length; ++i) {\r\n      // 如果每个 children 是 string/number 转换成 vnode\r\n      if (is.primitive(children[i]))\r\n        children[i] = vnode(\r\n          undefined,\r\n          undefined,\r\n          undefined,\r\n          children[i],\r\n          undefined\r\n        );\r\n    }\r\n  }\r\n  // 如果是 svg 添加 namespace\r\n  if (\r\n    sel[0] === \"s\" \u0026\u0026\r\n    sel[1] === \"v\" \u0026\u0026\r\n    sel[2] === \"g\" \u0026\u0026\r\n    (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")\r\n  ) {\r\n    addNS(data, children, sel);\r\n  }\r\n  return vnode(sel, data, children, text, undefined);\r\n}\r\n```\r\n\r\n### patch\r\n\r\n```typescript\r\n// 调用 init 返回 patch  \r\n\r\n  function emptyNodeAt(elm: Element) {\r\n    const id = elm.id ? \"#\" + elm.id : \"\";\r\n\r\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\r\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\r\n    const classes = elm.getAttribute(\"class\");\r\n\r\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\r\n    // document.querySelector('div').tagName =\u003e DIV\r\n    // div#id.classa.classb / div#id / div.class / div\r\n    return vnode(\r\n      api.tagName(elm).toLowerCase() + id + c,\r\n      {},\r\n      [],\r\n      undefined,\r\n      elm\r\n    );\r\n  }\r\n\r\nreturn function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\r\n    let i: number, elm: Node, parent: Node;\r\n    const insertedVnodeQueue: VNodeQueue = [];\r\n\t  // 调用 module 中的 pre hook \r\n    for (i = 0; i \u003c cbs.pre.length; ++i) cbs.pre[i]();\r\n\t\t\r\n\t  // 如果 oldVnode 是 Element 转换为空的 vnode\r\n    if (!isVnode(oldVnode)) {\r\n      oldVnode = emptyNodeAt(oldVnode);\r\n    }\r\n\t\t\t\r\n   \t// \u003e 如果相同，调用 patchVnode，如果不相同，会调用 createElm 来创建一个新的 dom 节点，然后如果存在父节点，便将其插入到 dom 上，然后移除旧的 dom 节点来完成更新。\r\n  \r\n\t  // oldVnode vnode sel key is 相同\r\n    if (sameVnode(oldVnode, vnode)) {\r\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\r\n    } else {\r\n      elm = oldVnode.elm!;\r\n      // ele parentNode\r\n      parent = api.parentNode(elm) as Node;\r\n\t\t\t// 创建\r\n      createElm(vnode, insertedVnodeQueue);\r\n\t\t\t\r\n      // 有父节点\r\n      if (parent !== null) {\r\n        // insert dom\r\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\r\n        // remove vnode\r\n        removeVnodes(parent, [oldVnode], 0, 0);\r\n      }\r\n    }\r\n\t\t\r\n  // 调用元素上的 insert hook，insert  hook 在 module 上不支持\r\n    for (i = 0; i \u003c insertedVnodeQueue.length; ++i) {\r\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\r\n    }\r\n\t  // 调用 module post hook\r\n    for (i = 0; i \u003c cbs.post.length; ++i) cbs.post[i]();\r\n    return vnode;\r\n  };\r\n```\r\n\r\n\u003eThe following hooks are available for modules: `pre`, `create`, `update`, `destroy`, `remove`, `post`\r\n\u003e\r\n\u003eThe following hooks are available in the `hook` property of individual elements: `init`, `create`, `insert`, `prepatch`, `update`, `postpatch`, `destroy`, `remove`.\r\n\r\n### createElm\r\n\r\n```typescript\r\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\r\n    let i: any;\r\n    let data = vnode.data;\r\n    // 调用元素的 init hook\r\n    if (data !== undefined) {\r\n      const init = data.hook?.init;\r\n      if (isDef(init)) {\r\n        init(vnode);\r\n        data = vnode.data;\r\n      }\r\n    }\r\n    const children = vnode.children;\r\n    \r\n    // 创建注释节点\r\n    const sel = vnode.sel;\r\n    if (sel === \"!\") {\r\n      if (isUndef(vnode.text)) {\r\n        vnode.text = \"\";\r\n      }\r\n      vnode.elm = api.createComment(vnode.text!);\r\n    } else if (sel !== undefined) {\r\n      // Parse selector\r\n      const hashIdx = sel.indexOf(\"#\");\r\n      const dotIdx = sel.indexOf(\".\", hashIdx);\r\n      // div#box\r\n      const hash = hashIdx \u003e 0 ? hashIdx : sel.length;\r\n      // div.boxclass\r\n      const dot = dotIdx \u003e 0 ? dotIdx : sel.length;\r\n      const tag =\r\n        hashIdx !== -1 || dotIdx !== -1\r\n          ? sel.slice(0, Math.min(hash, dot))\r\n          : sel;\r\n      const elm = (vnode.elm =\r\n        isDef(data) \u0026\u0026 isDef((i = data.ns))\r\n          ? api.createElementNS(i, tag, data)\r\n          : api.createElement(tag, data));\r\n      if (hash \u003c dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\r\n      if (dotIdx \u003e 0)\r\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\r\n      // 调用 module 的 create hook\r\n      for (i = 0; i \u003c cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\r\n      // 挂在子节点\r\n      if (is.array(children)) {\r\n        for (i = 0; i \u003c children.length; ++i) {\r\n          const ch = children[i];\r\n          if (ch != null) {\r\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\r\n          }\r\n        }\r\n      } else if (is.primitive(vnode.text)) {\r\n        // 插入 文本节点\r\n        api.appendChild(elm, api.createTextNode(vnode.text));\r\n      }\r\n      // 执行 vnode data hook\r\n      const hook = vnode.data!.hook;\r\n      if (isDef(hook)) {\r\n        // 执行 hook create\r\n        hook.create?.(emptyNode, vnode);\r\n        if (hook.insert) {\r\n          // insert hook 存储起来 等 dom 插入后才会调用，这里用个数组来保存能避免调用时再次对 vnode 树做遍历\r\n          insertedVnodeQueue.push(vnode);\r\n        }\r\n      }\r\n    } else {\r\n      // 文本节点\r\n      vnode.elm = api.createTextNode(vnode.text!);\r\n    }\r\n    return vnode.elm;\r\n  }\r\n```\r\n\r\n\r\n\r\n### patchVnode\r\n\r\n```typescript\r\nfunction patchVnode(\r\n    oldVnode: VNode,\r\n    vnode: VNode,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    const hook = vnode.data?.hook;\r\n    // 执行 prepatch hook\r\n    hook?.prepatch?.(oldVnode, vnode);\r\n    const elm = (vnode.elm = oldVnode.elm)!;\r\n    const oldCh = oldVnode.children as VNode[];\r\n    const ch = vnode.children as VNode[];\r\n     // 新 旧 vnode 相同\r\n    if (oldVnode === vnode) return;\r\n    // 执行 cbs update hook，vnode update hook\r\n    if (vnode.data !== undefined) {\r\n      for (let i = 0; i \u003c cbs.update.length; ++i)\r\n        cbs.update[i](oldVnode, vnode);\r\n      vnode.data.hook?.update?.(oldVnode, vnode);\r\n    }\r\n    // 是没有定义的\r\n    if (isUndef(vnode.text)) {\r\n      // 均存在 children 且不相同，调用 updateChildren\r\n    \r\n      // 定义过 children\r\n      if (isDef(oldCh) \u0026\u0026 isDef(ch)) {\r\n        // old children 不等于 new children\r\n        // 更新 updateChildren\r\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\r\n      } else if (isDef(ch)) { // 只定义了 new children\r\n        // 新 vnode 存在 children，旧 vnode 不存在 children，如果旧 vnode 存在 text 先清空，然后调用 addVnodes\r\n        \r\n        // 如果是 text，设置内容\r\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\r\n        // 添加 vnode\r\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n      } else if (isDef(oldCh)) { // 只定义 old children\r\n        // 新 vnode 不存在 children，旧 vnode 存在 children，调用 removeVnodes 移除 children\r\n        \r\n        // 移除 vnode\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      } else if (isDef(oldVnode.text)) { // 只定义了 old vnode text\r\n        // 设置内容\r\n        api.setTextContent(elm, \"\");\r\n      }\r\n    } else if (oldVnode.text !== vnode.text) { // old vnode text 和 new vnode text 不一样\r\n      // 均不存在 children，新 vnode 不存在 text，移除旧 vnode 的 text\r\n      \r\n      // 如果定义了 old children\r\n      if (isDef(oldCh)) {\r\n        // 移除\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      }\r\n      // 均存在 text，更新 text\r\n      \r\n      // 设置新内容\r\n      api.setTextContent(elm, vnode.text!);\r\n    }\r\n    // 执行 postpatch hook\r\n    hook?.postpatch?.(oldVnode, vnode);\r\n  }\r\n```\r\n\r\n### updateChildren\r\n\r\n```typescript\r\n  function updateChildren(\r\n    parentElm: Node,\r\n    oldCh: VNode[],\r\n    newCh: VNode[],\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    let oldStartIdx = 0; // 旧 头 索引\r\n    let newStartIdx = 0; // 新 头 索引\r\n    let oldEndIdx = oldCh.length - 1; // 旧 尾 索引\r\n    let oldStartVnode = oldCh[0]; // 旧 头 Vnode\r\n    let oldEndVnode = oldCh[oldEndIdx]; // 旧 尾 Vnode\r\n    let newEndIdx = newCh.length - 1; // 新 尾 索引\r\n    let newStartVnode = newCh[0]; // 新 头 Vnode\r\n    let newEndVnode = newCh[newEndIdx]; // 新 尾 Vnode\r\n    let oldKeyToIdx: KeyToIndexMap | undefined;\r\n    let idxInOld: number;\r\n    let elmToMove: VNode;\r\n    let before: any;\r\n\r\n    // 循环 从 头 到 尾 处理（新/旧）\r\n    while (oldStartIdx \u003c= oldEndIdx \u0026\u0026 newStartIdx \u003c= newEndIdx) {\r\n      // 如果 头尾（新/旧）其中有为 null 重新赋值，并且为元素数组中 添加/减少 一位\r\n      if (oldStartVnode == null) {\r\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\r\n      } else if (oldEndVnode == null) {\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n      } else if (newStartVnode == null) {\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (newEndVnode == null) {\r\n        newEndVnode = newCh[--newEndIdx];\r\n\r\n        // 如果相同 对比 新/旧 内容变化然后更新 DOM\r\n        // 新/旧 头Vnode 赋值\r\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n\r\n        // 节点移动到右边 更新 DOM\r\n        // 把更新的内容移动插入到旧节点最后\r\n        // 旧头索引 ++\r\n        // 新尾索引 --\r\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n        // Vnode moved right\r\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\r\n        api.insertBefore(\r\n          parentElm,\r\n          oldStartVnode.elm!,\r\n          api.nextSibling(oldEndVnode.elm!)\r\n        );\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n\r\n        // 节点移动到左边 更新 DOM\r\n        // 把更新的内容移动插入到旧节点最前\r\n        // 旧尾 --\r\n        // 新头 ++\r\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n        // Vnode moved left\r\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\r\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n\r\n\r\n        // 如果不是以上情况\r\n        // 开始节点是一个新节点\r\n        // 如果没有 key，创建 DOM 插入到前方\r\n        // 如果有 key，判断 sel 是否相同，如果不同创建 DOM 如果相同则代表是相同节点\r\n      } else {\r\n\r\n        // 方便通过新节点的key找到旧节点数组的索引\r\n        if (oldKeyToIdx === undefined) {\r\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n        // 用新节点的key 找到老节点的索引\r\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\r\n\r\n        // 如果是新节点\r\n        if (isUndef(idxInOld)) {\r\n          // New element\r\n          api.insertBefore(\r\n            parentElm,\r\n            createElm(newStartVnode, insertedVnodeQueue),\r\n            oldStartVnode.elm!\r\n          );\r\n        } else {\r\n          // 旧节点\r\n          // 取出旧节点\r\n          elmToMove = oldCh[idxInOld];\r\n          // 新元素 直接创建一个新的插入\r\n          if (elmToMove.sel !== newStartVnode.sel) {\r\n            api.insertBefore(\r\n              parentElm,\r\n              createElm(newStartVnode, insertedVnodeQueue),\r\n              oldStartVnode.elm!\r\n            );\r\n          } else {\r\n            // 没有修改过 更新内部 DOM\r\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\r\n            // 把旧节点相应位置的元素设置为undefined\r\n            oldCh[idxInOld] = undefined as any;\r\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\r\n          }\r\n        }\r\n        // 插入完成后，索引增加\r\n        newStartVnode = newCh[++newStartIdx];\r\n      }\r\n    }\r\n\r\n    // 老节点 或 新节点遍历完成\r\n    if (oldStartIdx \u003c= oldEndIdx || newStartIdx \u003c= newEndIdx) {\r\n      if (oldStartIdx \u003e oldEndIdx) {\r\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\r\n        addVnodes(\r\n          parentElm,\r\n          before,\r\n          newCh,\r\n          newStartIdx,\r\n          newEndIdx,\r\n          insertedVnodeQueue\r\n        );\r\n      } else {\r\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n### addVnodes\r\n\r\n```typescript\r\n  function addVnodes(\r\n    parentElm: Node,\r\n    before: Node | null,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    for (; startIdx \u003c= endIdx; ++startIdx) {\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n### removeVnodes\r\n\r\n```typescript\r\n\r\n  function removeVnodes(\r\n    parentElm: Node,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number\r\n  ): void {\r\n    for (; startIdx \u003c= endIdx; ++startIdx) {\r\n      let listeners: number;\r\n      let rm: () =\u003e void;\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        if (isDef(ch.sel)) {\r\n          // ˙执行 ch data destroy hook\r\n          invokeDestroyHook(ch);\r\n          listeners = cbs.remove.length + 1;\r\n          rm = createRmCb(ch.elm!, listeners);\r\n          // 调用 module 中是 remove hook\r\n          for (let i = 0; i \u003c cbs.remove.length; ++i) cbs.remove[i](ch, rm);\r\n           // 调用 vnode 的 remove hook\r\n          const removeHook = ch?.data?.hook?.remove;\r\n          if (isDef(removeHook)) {\r\n            removeHook(ch, rm);\r\n          } else {\r\n            rm();\r\n          }\r\n        } else {\r\n          // Text node\r\n          api.removeChild(parentElm, ch.elm!);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n// 调用 destroy hook\r\nfunction invokeDestroyHook(vnode: VNode) {\r\n  const data = vnode.data;\r\n  if (data !== undefined) {\r\n    data?.hook?.destroy?.(vnode);\r\n    for (let i = 0; i \u003c cbs.destroy.length; ++i) cbs.destroy[i](vnode);\r\n    if (vnode.children !== undefined) {\r\n      for (let j = 0; j \u003c vnode.children.length; ++j) {\r\n        const child = vnode.children[j];\r\n        if (child != null \u0026\u0026 typeof child !== \"string\") {\r\n          invokeDestroyHook(child);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\nfunction createRmCb(childElm: Node, listeners: number) {\r\n  return function rmCb() {\r\n    if (--listeners === 0) {\r\n      const parent = api.parentNode(childElm) as Node;\r\n      api.removeChild(parent, childElm);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### createElm\r\n\r\n```typescript\r\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\r\n    let i: any;\r\n    let data = vnode.data;\r\n    if (data !== undefined) {\r\n      // 调用 init hook\r\n      const init = data.hook?.init;\r\n      if (isDef(init)) {\r\n        init(vnode);\r\n        data = vnode.data;\r\n      }\r\n    }\r\n    const children = vnode.children;\r\n    const sel = vnode.sel;\r\n    if (sel === \"!\") { // 注释\r\n      if (isUndef(vnode.text)) {\r\n        vnode.text = \"\";\r\n      }\r\n      vnode.elm = api.createComment(vnode.text!);\r\n    } else if (sel !== undefined) {\r\n      // Parse selector\r\n      const hashIdx = sel.indexOf(\"#\");\r\n      const dotIdx = sel.indexOf(\".\", hashIdx);\r\n      const hash = hashIdx \u003e 0 ? hashIdx : sel.length;\r\n      const dot = dotIdx \u003e 0 ? dotIdx : sel.length;\r\n      const tag =\r\n        hashIdx !== -1 || dotIdx !== -1\r\n          ? sel.slice(0, Math.min(hash, dot))\r\n          : sel;\r\n      const elm = (vnode.elm =\r\n        isDef(data) \u0026\u0026 isDef((i = data.ns))\r\n          ? api.createElementNS(i, tag, data)\r\n          : api.createElement(tag, data));\r\n      if (hash \u003c dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\r\n      if (dotIdx \u003e 0)\r\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\r\n      for (i = 0; i \u003c cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\r\n      if (is.array(children)) {\r\n        for (i = 0; i \u003c children.length; ++i) {\r\n          const ch = children[i];\r\n          if (ch != null) {\r\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\r\n          }\r\n        }\r\n      } else if (is.primitive(vnode.text)) {\r\n        api.appendChild(elm, api.createTextNode(vnode.text));\r\n      }\r\n      // 调用 create hook\r\n      const hook = vnode.data!.hook;\r\n      if (isDef(hook)) {\r\n        hook.create?.(emptyNode, vnode);\r\n        if (hook.insert) {\r\n          insertedVnodeQueue.push(vnode);\r\n        }\r\n      }\r\n    } else {\r\n      vnode.elm = api.createTextNode(vnode.text!);\r\n    }\r\n    return vnode.elm;\r\n  }\r\n```\r\n\r\n### thunk\r\n\r\n```typescript\r\nexport interface ThunkData extends VNodeData {\r\n  fn: () =\u003e VNode;\r\n  args: any[];\r\n}\r\n\r\nexport interface Thunk extends VNode {\r\n  data: ThunkData;\r\n}\r\n\r\nexport interface ThunkFn {\r\n  (sel: string, fn: (...args: any[]) =\u003e any, args: any[]): Thunk;\r\n  (sel: string, key: any, fn: (...args: any[]) =\u003e any, args: any[]): Thunk;\r\n}\r\n\r\n// thunk  fn 、 args 属性保存到 vnode 上，在 prepatch 时需要进行比较\r\n// 将 vnode 上的数据拷贝到 thunk 上， patchVnode 中判断，相同会结束 patchVnode\r\nfunction copyToThunk(vnode: VNode, thunk: VNode): void {\r\n  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;\r\n  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;\r\n  thunk.data = vnode.data;\r\n  thunk.children = vnode.children;\r\n  thunk.text = vnode.text;\r\n  thunk.elm = vnode.elm;\r\n}\r\n\r\nfunction init(thunk: VNode): void {\r\n  const cur = thunk.data as VNodeData;\r\n  const vnode = (cur.fn as any)(...cur.args!);\r\n  copyToThunk(vnode, thunk);\r\n}\r\n\r\nfunction prepatch(oldVnode: VNode, thunk: VNode): void {\r\n  let i: number;\r\n  const old = oldVnode.data as VNodeData;\r\n  const cur = thunk.data as VNodeData;\r\n  const oldArgs = old.args;\r\n  const args = cur.args;\r\n  //  如果 fn 不同或 args 长度不同，说明发生了变化，调用 fn 生成新的 vnode 并返回\r\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\r\n    copyToThunk((cur.fn as any)(...args!), thunk);\r\n    return;\r\n  }\r\n  // 如果每个参数发生变化，逻辑同上\r\n  for (i = 0; i \u003c (args as any).length; ++i) {\r\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\r\n      copyToThunk((cur.fn as any)(...args!), thunk);\r\n      return;\r\n    }\r\n  }\r\n  copyToThunk(oldVnode, thunk);\r\n}\r\n// 使用 h 返回 vnode\r\n// 添加 init prepatch hook\r\nexport const thunk = function thunk(\r\n  sel: string,\r\n  key?: any,\r\n  fn?: any,\r\n  args?: any\r\n): VNode {\r\n  if (args === undefined) {\r\n    args = fn;\r\n    fn = key;\r\n    key = undefined;\r\n  }\r\n  return h(sel, {\r\n    key: key,\r\n    hook: { init, prepatch },\r\n    fn: fn,\r\n    args: args,\r\n  });\r\n} as ThunkFn;\r\n\r\n```\r\n\r\n","comments":{"nodes":[]},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"author":{"login":"xiaotiandada","url":"https://github.com/xiaotiandada","avatarUrl":"https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d\u0026v=4"},"html":"\u003cp\u003e\u003ca href=\"https://github.com/creeperyang/blog/issues/33\"\u003e解析 snabbdom 源码，教你实现精简的 Virtual DOM 库\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://juejin.cn/post/6844903671906435080#heading-1\"\u003esnabbdom 源码阅读分析\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://juejin.cn/post/6844903831717806087\"\u003ehttps://juejin.cn/post/6844903831717806087\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gzg.me/posts/2021/snabbdom_source/\"\u003ehttps://gzg.me/posts/2021/snabbdom_source/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.cnblogs.com/xuntu/p/6800547.html\"\u003ehttps://www.cnblogs.com/xuntu/p/6800547.html\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e通常情况下，找到两棵任意的树之间最小修改的时间复杂度是 **O(n^3)**，这不可接受。幸好，我们可以对 Virtual DOM 树有这样的假设：\u003c/p\u003e\n\u003cp\u003e如果 oldVnode 和 vnode 不同（如 type 从 \u003ccode\u003ediv\u003c/code\u003e 变到 \u003ccode\u003ep\u003c/code\u003e，或者 \u003ccode\u003ekey\u003c/code\u003e 改变），意味着整个 vnode 被替换（因为我们通常不会去跨层移动 vnode ），所以我们没有必要去比较 vnode 的 子 vnode（children） 了。基于这个假设，我们可以 \u003cstrong\u003e按照层级分解\u003c/strong\u003e 树，这大大简化了复杂度，大到接近 \u003cstrong\u003eO(n)\u003c/strong\u003e 的复杂度：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://user-images.githubusercontent.com/8046480/27190439-0a875688-5227-11e7-9015-eb34142de8ce.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e此外，对于 children （数组）的比较，因为同层是很可能有移动的，顺\n序比较会无法最大化复用已有的 DOM。所以我们通过为每个 vnode 加上 key 来追踪这种顺序变动。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://user-images.githubusercontent.com/8046480/27191679-28085118-522b-11e7-92e9-fa0ed047f7cd.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e用 js 对象来描述 dom 树结构，然后用这个 js 对象来创建一棵真正的 dom 树，插入到文档中\u003c/li\u003e\n\u003cli\u003e当状态更新时，将新的 js 对象和旧的 js 对象进行比较，得到两个对象之间的差异\u003c/li\u003e\n\u003cli\u003e将差异应用到真正的 dom 上\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"vnode\"\u003evnode\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e// https://github.com/snabbdom/snabbdom/blob/master/src/vnode.ts\n// ...\nexport type Key = string | number | symbol;\n\nexport interface VNode {\n  sel: string | undefined;\n  data: VNodeData | undefined;\n  children: Array\u003cVNode | string\u003e | undefined;\n  elm: Node | undefined;\n  text: string | undefined;\n  key: Key | undefined;\n}\n\nexport interface VNodeData {\n  props?: Props;\n  attrs?: Attrs;\n  class?: Classes;\n  style?: VNodeStyle;\n  dataset?: Dataset;\n  on?: On;\n  attachData?: AttachData;\n  hook?: Hooks;\n  key?: Key;\n  ns?: string; // for SVGs\n  fn?: () =\u003e VNode; // for thunks\n  args?: any[]; // for thunks\n  is?: string; // for custom elements v1\n  [key: string]: any; // for any other 3rd party module\n}\n\nexport function vnode(\n  sel: string | undefined,\n  data: any | undefined,\n  children: Array\u003cVNode | string\u003e | undefined,\n  text: string | undefined,\n  elm: Element | Text | undefined\n): VNode {\n  const key = data === undefined ? undefined : data.key;\n  return { sel, data, children, text, elm, key };\n}\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"init\"\u003einit\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e// https://github.com/snabbdom/snabbdom/blob/master/src/init.ts\nimport { Module } from \"./modules/module\";\nimport { vnode, VNode } from \"./vnode\";\nimport * as is from \"./is\";\nimport { htmlDomApi, DOMAPI } from \"./htmldomapi\";\n\ntype NonUndefined\u003cT\u003e = T extends undefined ? never : T;\n\nfunction isUndef(s: any): boolean {\n  return s === undefined;\n}\nfunction isDef\u003cA\u003e(s: A): s is NonUndefined\u003cA\u003e {\n  return s !== undefined;\n}\n\ntype VNodeQueue = VNode[];\n\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined);\n\nfunction sameVnode(vnode1: VNode, vnode2: VNode): boolean {\n  const isSameKey = vnode1.key === vnode2.key;\n  const isSameIs = vnode1.data?.is === vnode2.data?.is;\n  const isSameSel = vnode1.sel === vnode2.sel;\n\n  return isSameSel \u0026\u0026 isSameKey \u0026\u0026 isSameIs;\n}\n\nfunction isVnode(vnode: any): vnode is VNode {\n  return vnode.sel !== undefined;\n}\n\ntype KeyToIndexMap = { [key: string]: number };\n\ntype ArraysOf\u003cT\u003e = {\n  [K in keyof T]: Array\u003cT[K]\u003e;\n};\n\ntype ModuleHooks = ArraysOf\u003cRequired\u003cModule\u003e\u003e;\n\nfunction createKeyToOldIdx(\n  children: VNode[],\n  beginIdx: number,\n  endIdx: number\n): KeyToIndexMap {\n  const map: KeyToIndexMap = {};\n  for (let i = beginIdx; i \u003c= endIdx; ++i) {\n    const key = children[i]?.key;\n    if (key !== undefined) {\n      map[key as string] = i;\n    }\n  }\n  return map;\n}\n\nconst hooks: Array\u003ckeyof Module\u003e = [\n  \"create\",\n  \"update\",\n  \"remove\",\n  \"destroy\",\n  \"pre\",\n  \"post\",\n];\n\nexport function init(modules: Array\u003cPartial\u003cModule\u003e\u003e, domApi?: DOMAPI) {\n  let i: number;\n  let j: number;\n  // 收集 module in the hook\n  const cbs: ModuleHooks = {\n    create: [],\n    update: [],\n    remove: [],\n    destroy: [],\n    pre: [],\n    post: [],\n  };\n    \n  // 如果没有传递 domApi 使用浏览器中和 dom 相关的 api \n  // https://github.com/snabbdom/snabbdom/blob/master/src/htmldomapi.ts\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;\n    \n  // 收集 module in the hook\n  for (i = 0; i \u003c hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j \u003c modules.length; ++j) {\n      const hook = modules[j][hooks[i]];\n      if (hook !== undefined) {\n        (cbs[hooks[i]] as any[]).push(hook);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm: Element) {\n    const id = elm.id ? \"#\" + elm.id : \"\";\n\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n    // weex https://github.com/vuejs/vue/blob/dev/src/platforms/weex/runtime/node-ops.js\n    const classes = elm.getAttribute(\"class\");\n\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n    return vnode(\n      api.tagName(elm).toLowerCase() + id + c,\n      {},\n      [],\n      undefined,\n      elm\n    );\n  }\n\n  function createRmCb(childElm: Node, listeners: number) {\n    return function rmCb() {\n      if (--listeners === 0) {\n        const parent = api.parentNode(childElm) as Node;\n        api.removeChild(parent, childElm);\n      }\n    };\n  }\n\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any;\n    let data = vnode.data;\n    if (data !== undefined) {\n      const init = data.hook?.init;\n      if (isDef(init)) {\n        init(vnode);\n        data = vnode.data;\n      }\n    }\n    const children = vnode.children;\n    const sel = vnode.sel;\n    if (sel === \"!\") {\n      if (isUndef(vnode.text)) {\n        vnode.text = \"\";\n      }\n      vnode.elm = api.createComment(vnode.text!);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf(\"#\");\n      const dotIdx = sel.indexOf(\".\", hashIdx);\n      const hash = hashIdx \u003e 0 ? hashIdx : sel.length;\n      const dot = dotIdx \u003e 0 ? dotIdx : sel.length;\n      const tag =\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel;\n      const elm = (vnode.elm =\n        isDef(data) \u0026\u0026 isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data));\n      if (hash \u003c dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n      if (dotIdx \u003e 0)\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n      for (i = 0; i \u003c cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      if (is.array(children)) {\n        for (i = 0; i \u003c children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      const hook = vnode.data!.hook;\n      if (isDef(hook)) {\n        hook.create?.(emptyNode, vnode);\n        if (hook.insert) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } else {\n      vnode.elm = api.createTextNode(vnode.text!);\n    }\n    return vnode.elm;\n  }\n\n  function addVnodes(\n    parentElm: Node,\n    before: Node | null,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    for (; startIdx \u003c= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n      }\n    }\n  }\n\n  function invokeDestroyHook(vnode: VNode) {\n    const data = vnode.data;\n    if (data !== undefined) {\n      data?.hook?.destroy?.(vnode);\n      for (let i = 0; i \u003c cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n      if (vnode.children !== undefined) {\n        for (let j = 0; j \u003c vnode.children.length; ++j) {\n          const child = vnode.children[j];\n          if (child != null \u0026\u0026 typeof child !== \"string\") {\n            invokeDestroyHook(child);\n          }\n        }\n      }\n    }\n  }\n\n  function removeVnodes(\n    parentElm: Node,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number\n  ): void {\n    for (; startIdx \u003c= endIdx; ++startIdx) {\n      let listeners: number;\n      let rm: () =\u003e void;\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        if (isDef(ch.sel)) {\n          invokeDestroyHook(ch);\n          listeners = cbs.remove.length + 1;\n          rm = createRmCb(ch.elm!, listeners);\n          for (let i = 0; i \u003c cbs.remove.length; ++i) cbs.remove[i](ch, rm);\n          const removeHook = ch?.data?.hook?.remove;\n          if (isDef(removeHook)) {\n            removeHook(ch, rm);\n          } else {\n            rm();\n          }\n        } else {\n          // Text node\n          api.removeChild(parentElm, ch.elm!);\n        }\n      }\n    }\n  }\n\n  function updateChildren(\n    parentElm: Node,\n    oldCh: VNode[],\n    newCh: VNode[],\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx: KeyToIndexMap | undefined;\n    let idxInOld: number;\n    let elmToMove: VNode;\n    let before: any;\n\n    while (oldStartIdx \u003c= oldEndIdx \u0026\u0026 newStartIdx \u003c= newEndIdx) {\n      if (oldStartVnode == null) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n      } else if (oldEndVnode == null) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (newStartVnode == null) {\n        newStartVnode = newCh[++newStartIdx];\n      } else if (newEndVnode == null) {\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(\n          parentElm,\n          oldStartVnode.elm!,\n          api.nextSibling(oldEndVnode.elm!)\n        );\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (oldKeyToIdx === undefined) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\n        if (isUndef(idxInOld)) {\n          // New element\n          api.insertBefore(\n            parentElm,\n            createElm(newStartVnode, insertedVnodeQueue),\n            oldStartVnode.elm!\n          );\n        } else {\n          elmToMove = oldCh[idxInOld];\n          if (elmToMove.sel !== newStartVnode.sel) {\n            api.insertBefore(\n              parentElm,\n              createElm(newStartVnode, insertedVnodeQueue),\n              oldStartVnode.elm!\n            );\n          } else {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined as any;\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx \u003c= oldEndIdx || newStartIdx \u003c= newEndIdx) {\n      if (oldStartIdx \u003e oldEndIdx) {\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(\n          parentElm,\n          before,\n          newCh,\n          newStartIdx,\n          newEndIdx,\n          insertedVnodeQueue\n        );\n      } else {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n  }\n\n  function patchVnode(\n    oldVnode: VNode,\n    vnode: VNode,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    const hook = vnode.data?.hook;\n    hook?.prepatch?.(oldVnode, vnode);\n    const elm = (vnode.elm = oldVnode.elm)!;\n    const oldCh = oldVnode.children as VNode[];\n    const ch = vnode.children as VNode[];\n    if (oldVnode === vnode) return;\n    if (vnode.data !== undefined) {\n      for (let i = 0; i \u003c cbs.update.length; ++i)\n        cbs.update[i](oldVnode, vnode);\n      vnode.data.hook?.update?.(oldVnode, vnode);\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) \u0026\u0026 isDef(ch)) {\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        api.setTextContent(elm, \"\");\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      }\n      api.setTextContent(elm, vnode.text!);\n    }\n    hook?.postpatch?.(oldVnode, vnode);\n  }\n\n  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\n    let i: number, elm: Node, parent: Node;\n    const insertedVnodeQueue: VNodeQueue = [];\n    for (i = 0; i \u003c cbs.pre.length; ++i) cbs.pre[i]();\n\n    if (!isVnode(oldVnode)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      elm = oldVnode.elm!;\n      parent = api.parentNode(elm) as Node;\n\n      createElm(vnode, insertedVnodeQueue);\n\n      if (parent !== null) {\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n\n    for (i = 0; i \u003c insertedVnodeQueue.length; ++i) {\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\n    }\n    for (i = 0; i \u003c cbs.post.length; ++i) cbs.post[i]();\n    return vnode;\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"h\"\u003eh\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003eimport { vnode, VNode, VNodeData } from \"./vnode\";\nimport * as is from \"./is\";\n\nexport type VNodes = VNode[];\nexport type VNodeChildElement = VNode | string | number | undefined | null;\nexport type ArrayOrElement\u003cT\u003e = T | T[];\nexport type VNodeChildren = ArrayOrElement\u003cVNodeChildElement\u003e;\n\nfunction addNS(\n  data: any,\n  children: VNodes | undefined,\n  sel: string | undefined\n): void {\n  data.ns = \"http://www.w3.org/2000/svg\";\n  if (sel !== \"foreignObject\" \u0026\u0026 children !== undefined) {\n    for (let i = 0; i \u003c children.length; ++i) {\n      const childData = children[i].data;\n      if (childData !== undefined) {\n        addNS(childData, children[i].children as VNodes, children[i].sel);\n      }\n    }\n  }\n}\n\nexport function h(sel: string): VNode;\nexport function h(sel: string, data: VNodeData | null): VNode;\nexport function h(sel: string, children: VNodeChildren): VNode;\nexport function h(\n  sel: string,\n  data: VNodeData | null,\n  children: VNodeChildren\n): VNode;\nexport function h(sel: any, b?: any, c?: any): VNode {\n  let data: VNodeData = {};\n  let children: any;\n  let text: any;\n  let i: number;\n  // c 不为空 可能是 [] / string\n  if (c !== undefined) {\n    // b 不为空 有 {} options (认为是 VNodeData)\n    if (b !== null) {\n      data = b;\n    }\n    // 如果 c 是 []\n    if (is.array(c)) {\n      children = c;\n    } else if (is.primitive(c)) { // c 是 string / number 应该认为是 text node\n      text = c;\n    } else if (c \u0026\u0026 c.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ c ]\n      children = [c];\n    }\n  } else if (b !== undefined \u0026\u0026 b !== null) { // 如果是 b 不为空\n    // 如果是 array 说明是 VNodeChildren\n    if (is.array(b)) {\n      children = b;\n    } else if (is.primitive(b)) { // 如果是 string/number 应该认为是 text node\n      text = b;\n    } else if (b \u0026\u0026 b.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ b ]\n      children = [b];\n    } else { // 认为 b 是 VNodeData\n      data = b;\n    }\n  }\n  // 如果存在 children\n  if (children !== undefined) {\n    for (i = 0; i \u003c children.length; ++i) {\n      // 如果每个 children 是 string/number 转换成 vnode\n      if (is.primitive(children[i]))\n        children[i] = vnode(\n          undefined,\n          undefined,\n          undefined,\n          children[i],\n          undefined\n        );\n    }\n  }\n  // 如果是 svg 添加 namespace\n  if (\n    sel[0] === \"s\" \u0026\u0026\n    sel[1] === \"v\" \u0026\u0026\n    sel[2] === \"g\" \u0026\u0026\n    (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")\n  ) {\n    addNS(data, children, sel);\n  }\n  return vnode(sel, data, children, text, undefined);\n}\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"patch\"\u003epatch\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e// 调用 init 返回 patch  \n\n  function emptyNodeAt(elm: Element) {\n    const id = elm.id ? \"#\" + elm.id : \"\";\n\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n    const classes = elm.getAttribute(\"class\");\n\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n    // document.querySelector('div').tagName =\u003e DIV\n    // div#id.classa.classb / div#id / div.class / div\n    return vnode(\n      api.tagName(elm).toLowerCase() + id + c,\n      {},\n      [],\n      undefined,\n      elm\n    );\n  }\n\nreturn function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\n    let i: number, elm: Node, parent: Node;\n    const insertedVnodeQueue: VNodeQueue = [];\n      // 调用 module 中的 pre hook \n    for (i = 0; i \u003c cbs.pre.length; ++i) cbs.pre[i]();\n        \n      // 如果 oldVnode 是 Element 转换为空的 vnode\n    if (!isVnode(oldVnode)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n            \n       // \u003e 如果相同，调用 patchVnode，如果不相同，会调用 createElm 来创建一个新的 dom 节点，然后如果存在父节点，便将其插入到 dom 上，然后移除旧的 dom 节点来完成更新。\n  \n      // oldVnode vnode sel key is 相同\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      elm = oldVnode.elm!;\n      // ele parentNode\n      parent = api.parentNode(elm) as Node;\n            // 创建\n      createElm(vnode, insertedVnodeQueue);\n            \n      // 有父节点\n      if (parent !== null) {\n        // insert dom\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\n        // remove vnode\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n        \n  // 调用元素上的 insert hook，insert  hook 在 module 上不支持\n    for (i = 0; i \u003c insertedVnodeQueue.length; ++i) {\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\n    }\n      // 调用 module post hook\n    for (i = 0; i \u003c cbs.post.length; ++i) cbs.post[i]();\n    return vnode;\n  };\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003eThe following hooks are available for modules: \u003ccode\u003epre\u003c/code\u003e, \u003ccode\u003ecreate\u003c/code\u003e, \u003ccode\u003eupdate\u003c/code\u003e, \u003ccode\u003edestroy\u003c/code\u003e, \u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003epost\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe following hooks are available in the \u003ccode\u003ehook\u003c/code\u003e property of individual elements: \u003ccode\u003einit\u003c/code\u003e, \u003ccode\u003ecreate\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, \u003ccode\u003eprepatch\u003c/code\u003e, \u003ccode\u003eupdate\u003c/code\u003e, \u003ccode\u003epostpatch\u003c/code\u003e, \u003ccode\u003edestroy\u003c/code\u003e, \u003ccode\u003eremove\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"createelm\"\u003ecreateElm\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any;\n    let data = vnode.data;\n    // 调用元素的 init hook\n    if (data !== undefined) {\n      const init = data.hook?.init;\n      if (isDef(init)) {\n        init(vnode);\n        data = vnode.data;\n      }\n    }\n    const children = vnode.children;\n    \n    // 创建注释节点\n    const sel = vnode.sel;\n    if (sel === \"!\") {\n      if (isUndef(vnode.text)) {\n        vnode.text = \"\";\n      }\n      vnode.elm = api.createComment(vnode.text!);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf(\"#\");\n      const dotIdx = sel.indexOf(\".\", hashIdx);\n      // div#box\n      const hash = hashIdx \u003e 0 ? hashIdx : sel.length;\n      // div.boxclass\n      const dot = dotIdx \u003e 0 ? dotIdx : sel.length;\n      const tag =\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel;\n      const elm = (vnode.elm =\n        isDef(data) \u0026\u0026 isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data));\n      if (hash \u003c dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n      if (dotIdx \u003e 0)\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n      // 调用 module 的 create hook\n      for (i = 0; i \u003c cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      // 挂在子节点\n      if (is.array(children)) {\n        for (i = 0; i \u003c children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        // 插入 文本节点\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      // 执行 vnode data hook\n      const hook = vnode.data!.hook;\n      if (isDef(hook)) {\n        // 执行 hook create\n        hook.create?.(emptyNode, vnode);\n        if (hook.insert) {\n          // insert hook 存储起来 等 dom 插入后才会调用，这里用个数组来保存能避免调用时再次对 vnode 树做遍历\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } else {\n      // 文本节点\n      vnode.elm = api.createTextNode(vnode.text!);\n    }\n    return vnode.elm;\n  }\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"patchvnode\"\u003epatchVnode\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003efunction patchVnode(\n    oldVnode: VNode,\n    vnode: VNode,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    const hook = vnode.data?.hook;\n    // 执行 prepatch hook\n    hook?.prepatch?.(oldVnode, vnode);\n    const elm = (vnode.elm = oldVnode.elm)!;\n    const oldCh = oldVnode.children as VNode[];\n    const ch = vnode.children as VNode[];\n     // 新 旧 vnode 相同\n    if (oldVnode === vnode) return;\n    // 执行 cbs update hook，vnode update hook\n    if (vnode.data !== undefined) {\n      for (let i = 0; i \u003c cbs.update.length; ++i)\n        cbs.update[i](oldVnode, vnode);\n      vnode.data.hook?.update?.(oldVnode, vnode);\n    }\n    // 是没有定义的\n    if (isUndef(vnode.text)) {\n      // 均存在 children 且不相同，调用 updateChildren\n    \n      // 定义过 children\n      if (isDef(oldCh) \u0026\u0026 isDef(ch)) {\n        // old children 不等于 new children\n        // 更新 updateChildren\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      } else if (isDef(ch)) { // 只定义了 new children\n        // 新 vnode 存在 children，旧 vnode 不存在 children，如果旧 vnode 存在 text 先清空，然后调用 addVnodes\n        \n        // 如果是 text，设置内容\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\n        // 添加 vnode\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) { // 只定义 old children\n        // 新 vnode 不存在 children，旧 vnode 存在 children，调用 removeVnodes 移除 children\n        \n        // 移除 vnode\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) { // 只定义了 old vnode text\n        // 设置内容\n        api.setTextContent(elm, \"\");\n      }\n    } else if (oldVnode.text !== vnode.text) { // old vnode text 和 new vnode text 不一样\n      // 均不存在 children，新 vnode 不存在 text，移除旧 vnode 的 text\n      \n      // 如果定义了 old children\n      if (isDef(oldCh)) {\n        // 移除\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      }\n      // 均存在 text，更新 text\n      \n      // 设置新内容\n      api.setTextContent(elm, vnode.text!);\n    }\n    // 执行 postpatch hook\n    hook?.postpatch?.(oldVnode, vnode);\n  }\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"updatechildren\"\u003eupdateChildren\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e  function updateChildren(\n    parentElm: Node,\n    oldCh: VNode[],\n    newCh: VNode[],\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    let oldStartIdx = 0; // 旧 头 索引\n    let newStartIdx = 0; // 新 头 索引\n    let oldEndIdx = oldCh.length - 1; // 旧 尾 索引\n    let oldStartVnode = oldCh[0]; // 旧 头 Vnode\n    let oldEndVnode = oldCh[oldEndIdx]; // 旧 尾 Vnode\n    let newEndIdx = newCh.length - 1; // 新 尾 索引\n    let newStartVnode = newCh[0]; // 新 头 Vnode\n    let newEndVnode = newCh[newEndIdx]; // 新 尾 Vnode\n    let oldKeyToIdx: KeyToIndexMap | undefined;\n    let idxInOld: number;\n    let elmToMove: VNode;\n    let before: any;\n\n    // 循环 从 头 到 尾 处理（新/旧）\n    while (oldStartIdx \u003c= oldEndIdx \u0026\u0026 newStartIdx \u003c= newEndIdx) {\n      // 如果 头尾（新/旧）其中有为 null 重新赋值，并且为元素数组中 添加/减少 一位\n      if (oldStartVnode == null) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n      } else if (oldEndVnode == null) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (newStartVnode == null) {\n        newStartVnode = newCh[++newStartIdx];\n      } else if (newEndVnode == null) {\n        newEndVnode = newCh[--newEndIdx];\n\n        // 如果相同 对比 新/旧 内容变化然后更新 DOM\n        // 新/旧 头Vnode 赋值\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n\n        // 节点移动到右边 更新 DOM\n        // 把更新的内容移动插入到旧节点最后\n        // 旧头索引 ++\n        // 新尾索引 --\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(\n          parentElm,\n          oldStartVnode.elm!,\n          api.nextSibling(oldEndVnode.elm!)\n        );\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n\n        // 节点移动到左边 更新 DOM\n        // 把更新的内容移动插入到旧节点最前\n        // 旧尾 --\n        // 新头 ++\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n\n\n        // 如果不是以上情况\n        // 开始节点是一个新节点\n        // 如果没有 key，创建 DOM 插入到前方\n        // 如果有 key，判断 sel 是否相同，如果不同创建 DOM 如果相同则代表是相同节点\n      } else {\n\n        // 方便通过新节点的key找到旧节点数组的索引\n        if (oldKeyToIdx === undefined) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        // 用新节点的key 找到老节点的索引\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\n\n        // 如果是新节点\n        if (isUndef(idxInOld)) {\n          // New element\n          api.insertBefore(\n            parentElm,\n            createElm(newStartVnode, insertedVnodeQueue),\n            oldStartVnode.elm!\n          );\n        } else {\n          // 旧节点\n          // 取出旧节点\n          elmToMove = oldCh[idxInOld];\n          // 新元素 直接创建一个新的插入\n          if (elmToMove.sel !== newStartVnode.sel) {\n            api.insertBefore(\n              parentElm,\n              createElm(newStartVnode, insertedVnodeQueue),\n              oldStartVnode.elm!\n            );\n          } else {\n            // 没有修改过 更新内部 DOM\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            // 把旧节点相应位置的元素设置为undefined\n            oldCh[idxInOld] = undefined as any;\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\n          }\n        }\n        // 插入完成后，索引增加\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    // 老节点 或 新节点遍历完成\n    if (oldStartIdx \u003c= oldEndIdx || newStartIdx \u003c= newEndIdx) {\n      if (oldStartIdx \u003e oldEndIdx) {\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(\n          parentElm,\n          before,\n          newCh,\n          newStartIdx,\n          newEndIdx,\n          insertedVnodeQueue\n        );\n      } else {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n  }\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"addvnodes\"\u003eaddVnodes\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e  function addVnodes(\n    parentElm: Node,\n    before: Node | null,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    for (; startIdx \u003c= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n      }\n    }\n  }\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"removevnodes\"\u003eremoveVnodes\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e\n  function removeVnodes(\n    parentElm: Node,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number\n  ): void {\n    for (; startIdx \u003c= endIdx; ++startIdx) {\n      let listeners: number;\n      let rm: () =\u003e void;\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        if (isDef(ch.sel)) {\n          // ˙执行 ch data destroy hook\n          invokeDestroyHook(ch);\n          listeners = cbs.remove.length + 1;\n          rm = createRmCb(ch.elm!, listeners);\n          // 调用 module 中是 remove hook\n          for (let i = 0; i \u003c cbs.remove.length; ++i) cbs.remove[i](ch, rm);\n           // 调用 vnode 的 remove hook\n          const removeHook = ch?.data?.hook?.remove;\n          if (isDef(removeHook)) {\n            removeHook(ch, rm);\n          } else {\n            rm();\n          }\n        } else {\n          // Text node\n          api.removeChild(parentElm, ch.elm!);\n        }\n      }\n    }\n  }\n\n// 调用 destroy hook\nfunction invokeDestroyHook(vnode: VNode) {\n  const data = vnode.data;\n  if (data !== undefined) {\n    data?.hook?.destroy?.(vnode);\n    for (let i = 0; i \u003c cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n    if (vnode.children !== undefined) {\n      for (let j = 0; j \u003c vnode.children.length; ++j) {\n        const child = vnode.children[j];\n        if (child != null \u0026\u0026 typeof child !== \"string\") {\n          invokeDestroyHook(child);\n        }\n      }\n    }\n  }\n}\n\n\nfunction createRmCb(childElm: Node, listeners: number) {\n  return function rmCb() {\n    if (--listeners === 0) {\n      const parent = api.parentNode(childElm) as Node;\n      api.removeChild(parent, childElm);\n    }\n  };\n}\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"createelm-1\"\u003ecreateElm\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003e  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any;\n    let data = vnode.data;\n    if (data !== undefined) {\n      // 调用 init hook\n      const init = data.hook?.init;\n      if (isDef(init)) {\n        init(vnode);\n        data = vnode.data;\n      }\n    }\n    const children = vnode.children;\n    const sel = vnode.sel;\n    if (sel === \"!\") { // 注释\n      if (isUndef(vnode.text)) {\n        vnode.text = \"\";\n      }\n      vnode.elm = api.createComment(vnode.text!);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf(\"#\");\n      const dotIdx = sel.indexOf(\".\", hashIdx);\n      const hash = hashIdx \u003e 0 ? hashIdx : sel.length;\n      const dot = dotIdx \u003e 0 ? dotIdx : sel.length;\n      const tag =\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel;\n      const elm = (vnode.elm =\n        isDef(data) \u0026\u0026 isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data));\n      if (hash \u003c dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n      if (dotIdx \u003e 0)\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n      for (i = 0; i \u003c cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      if (is.array(children)) {\n        for (i = 0; i \u003c children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      // 调用 create hook\n      const hook = vnode.data!.hook;\n      if (isDef(hook)) {\n        hook.create?.(emptyNode, vnode);\n        if (hook.insert) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } else {\n      vnode.elm = api.createTextNode(vnode.text!);\n    }\n    return vnode.elm;\n  }\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"thunk\"\u003ethunk\u003c/h3\u003e\n\u003cpre class=\"language-typescript\"\u003e\u003ccode class=\"language-typescript\"\u003eexport interface ThunkData extends VNodeData {\n  fn: () =\u003e VNode;\n  args: any[];\n}\n\nexport interface Thunk extends VNode {\n  data: ThunkData;\n}\n\nexport interface ThunkFn {\n  (sel: string, fn: (...args: any[]) =\u003e any, args: any[]): Thunk;\n  (sel: string, key: any, fn: (...args: any[]) =\u003e any, args: any[]): Thunk;\n}\n\n// thunk  fn 、 args 属性保存到 vnode 上，在 prepatch 时需要进行比较\n// 将 vnode 上的数据拷贝到 thunk 上， patchVnode 中判断，相同会结束 patchVnode\nfunction copyToThunk(vnode: VNode, thunk: VNode): void {\n  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;\n  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;\n  thunk.data = vnode.data;\n  thunk.children = vnode.children;\n  thunk.text = vnode.text;\n  thunk.elm = vnode.elm;\n}\n\nfunction init(thunk: VNode): void {\n  const cur = thunk.data as VNodeData;\n  const vnode = (cur.fn as any)(...cur.args!);\n  copyToThunk(vnode, thunk);\n}\n\nfunction prepatch(oldVnode: VNode, thunk: VNode): void {\n  let i: number;\n  const old = oldVnode.data as VNodeData;\n  const cur = thunk.data as VNodeData;\n  const oldArgs = old.args;\n  const args = cur.args;\n  //  如果 fn 不同或 args 长度不同，说明发生了变化，调用 fn 生成新的 vnode 并返回\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\n    copyToThunk((cur.fn as any)(...args!), thunk);\n    return;\n  }\n  // 如果每个参数发生变化，逻辑同上\n  for (i = 0; i \u003c (args as any).length; ++i) {\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\n      copyToThunk((cur.fn as any)(...args!), thunk);\n      return;\n    }\n  }\n  copyToThunk(oldVnode, thunk);\n}\n// 使用 h 返回 vnode\n// 添加 init prepatch hook\nexport const thunk = function thunk(\n  sel: string,\n  key?: any,\n  fn?: any,\n  args?: any\n): VNode {\n  if (args === undefined) {\n    args = fn;\n    fn = key;\n    key = undefined;\n  }\n  return h(sel, {\n    key: key,\n    hook: { init, prepatch },\n    fn: fn,\n    args: args,\n  });\n} as ThunkFn;\n\u003c/code\u003e\u003c/pre\u003e","attributes":{}},"themeConfig":{"title":"Blog(issues)","links":[{"title":"GitHub","url":"https://github.com/xiaotiandada/blog"},{"title":"Twitter","url":"https://twitter.com/XiaoTianIsMe"}]}},"__N_SSG":true},"page":"/[...path]","query":{"path":["MDU6SXNzdWU4NTI1MTQ2OTk="]},"buildId":"YPEk3V-eoVeml18YoUSCM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>