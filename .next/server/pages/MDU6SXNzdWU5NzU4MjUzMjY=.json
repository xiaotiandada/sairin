{"pageProps":{"post":{"id":"MDU6SXNzdWU5NzU4MjUzMjY=","url":"https://github.com/xiaotiandada/blog/issues/84","title":"React.memo 学习","updatedAt":"2022-01-05T08:38:30Z","createdAt":"2021-08-20T18:19:13Z","body":"## `React.memo`\r\n\r\n```react\r\nconst MyComponent = React.memo(function MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n});\r\n```\r\n\r\nhttps://zh-hans.reactjs.org/docs/react-api.html#reactmemo\r\n\r\n>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 `React.memo` 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\r\n>\r\n>`React.memo` 仅检查 props 变更。如果函数组件被 `React.memo` 包裹，且其实现中拥有 [`useState`](https://zh-hans.reactjs.org/docs/hooks-state.html)，[`useReducer`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer) 或 [`useContext`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext) 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。\r\n>\r\n>...\r\n\r\n[demo](https://codesandbox.io/s/react-memo-qknj7?file=/src/App.tsx) 代码都在这儿\r\n\r\n\r\n\r\n### 默认情况\r\n\r\n```tsx\r\nconsole.log(\"App Parent\");\r\n\r\nconst [time, setTime] = useState<string>(\"\");\r\nconst [time1, setTime1] = useState<string>(\"\");\r\n\r\n<div>\r\n  <div>Parent</div>\r\n  <ul>\r\n    <li>time: {time}</li>\r\n    <li>time1: {time1}</li>\r\n  </ul>\r\n  <button onClick={() => setTime(\"1111\")}>toggle</button>\r\n  <button onClick={() => setTime1(String(Date.now()))}>toggle1</button>\r\n  <button onClick={() => setTime1(\"0000000000\")}>toggle1</button>\r\n</div>\r\n```\r\n\r\n1. 默认执行 输出 ``App Parent`` 一次\r\n2. 组件内 useState 变动则会重新渲染一次\r\n\r\n\r\n\r\n### 默认组件 在组件内\r\n\r\n```tsx\r\n  const child1: React.FC = () => {\r\n    console.log(\"child1\");\r\n    return (\r\n      <div>\r\n        <div>child1</div>\r\n        <button onClick={() => setTime1(\"child1\")}>toggle</button>\r\n        <button onClick={() => setTime1(String(Date.now()))}>toggle</button>\r\n      </div>\r\n    );\r\n  };\r\n```\r\n\r\n1. 父组件渲染一次 child1 也渲染一次\r\n2. 父组件 useState 改动 父组件和 child1 渲染一次\r\n3. child1 组件 useState 改动 父组件和 child1 渲染一次\r\n\r\n\r\n\r\n### 默认组件 使用方式\r\n\r\n```tsx\r\n<div>{Child1()}</div>\r\n<Child2 />\r\n```\r\n\r\n```\r\nApp Parent \r\nChild1 \r\nChild2 \r\n\r\nApp Parent \r\nChild1 \r\n```\r\n\r\n1. 表现基本与上面一致\r\n2. 第一次 都渲染，后面 修改相同 useState 执行 Child1，修改不相同 useState 执行  Child1 Child2\r\n\r\n\r\n\r\n### Memo 在组件内\r\n\r\n```tsx\r\nconst Child3: React.FC = React.memo(function Child3() {\r\n  console.log(\"Child3\");\r\n  return (\r\n    <div>\r\n      <div>Child2</div>\r\n      <div>{time}</div>\r\n      <div>{time1}</div>\r\n    </div>\r\n  );\r\n});\r\n```\r\n\r\n1. 无效 表现和默认一致\r\n\r\n\r\n\r\n### 在组件内 无依赖 修改 useState\r\n\r\n```tsx\r\n  const Child4: React.FC = () => {\r\n    console.log(\"Child4\");\r\n    const [state, setstate] = useState(\"\");\r\n\r\n    return (\r\n      <div>\r\n        <div>{state}</div>\r\n        <button onClick={() => setstate(String(Date.now()))}>toggle</button>\r\n      </div>\r\n    );\r\n  };\r\n```\r\n\r\n1. 只渲染当前组件\r\n\r\n### 在组件外 默认组件 无依赖\r\n\r\n```tsx\r\nconst Outer1 = () => {\r\n  console.log(\"Outer1\");\r\n  return <div>Outer1</div>;\r\n};\r\n```\r\n\r\n1. 表现和默认一致\r\n\r\n```\r\nApp Parent \r\nOuter1 \r\n```\r\n\r\n\r\n\r\n### 在组件外 Momo 无依赖\r\n\r\n```tsx\r\nconst Outer2 = React.memo(function Outer2() {\r\n  console.log(\"Outer2\");\r\n  return <div>Outer2</div>;\r\n});\r\n```\r\n\r\n```\r\n\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nApp Parent \r\nOuter1\r\nApp Parent \r\nOuter1 \r\n```\r\n\r\n1. 只会渲染一次 父级 useState 改变不受影响\r\n\r\n### 在组件外 Memo useState 依赖\r\n\r\n```tsx\r\nconst Outer3: React.FC<{ time1: string }> = React.memo(function Outer3({\r\n  time1\r\n}) {\r\n  console.log(\"Outer3 time1\", time1);\r\n  return <div>Outer3 {time1}</div>;\r\n});\r\n```\r\n\r\n```\r\n\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nOuter3 time1 \"\" \r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630983888577 \r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630983892146 \r\n```\r\n\r\n1. 默认执行一次\r\n2. 依赖外 useState 变动不渲染\r\n3. 依赖 useState 变动渲染一次\r\n\r\n### 在组件外 Memo useState 依赖 ， 内部拥有 useState\r\n\r\n```tsx\r\nconst Outer4: React.FC<{ time1: string }> = React.memo(function Outer4({\r\n  time1\r\n}) {\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  console.log(\"Outer4\");\r\n  return (\r\n    <div>\r\n      <div>Outer4 state {state}</div>\r\n      <div>Outer4 time1 {time1}</div>\r\n      <button onClick={() => setstate(String(Date.now()))}>Toggle</button>\r\n    </div>\r\n  );\r\n});\r\n```\r\n\r\n```\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nOuter3 time1 \"\" \r\nOuter4 \r\nApp Parent \r\nOuter1 \r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630984999782 \r\nOuter4 \r\nOuter4 \r\n```\r\n\r\n1. 同上\r\n2. 内部 useState 变动渲染一次\r\n\r\n### 在组件外 Memo function 依赖 (在父级组件内定义)\r\n\r\n```tsx\r\nconst Outer5: React.FC<{ fn: () => void }> = React.memo(function Outer5({\r\n  fn\r\n}) {\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  console.log(\"Outer5\");\r\n  return (\r\n    <div>\r\n      <div>Outer5 state {state}</div>\r\n      <button onClick={() => setstate(String(Date.now()))}>Toggle</button>\r\n      <button onClick={() => fn()}>Fn</button>\r\n    </div>\r\n  );\r\n});\r\n\r\nconst Outer4Fn = () => {\r\n  console.log(\"Outer4Fn\");\r\n};\r\n```\r\n\r\n```\r\n\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nOuter3 time1 \"\" \r\nOuter4 \r\nOuter5 \r\n\r\nApp Parent \r\nOuter1 \r\nOuter5 \r\n\r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630985278410 \r\nOuter4 \r\nOuter5 \r\n\r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630985281298 \r\nOuter4 \r\nOuter5 \r\n\r\nOuter4Fn \r\nOuter4Fn \r\n```\r\n\r\n1. 默认渲染一次\r\n2. 修改父级组件 useState 渲染一次\r\n3. 执行 fn 不渲染\r\n\r\n应该是父级渲染导致方法重新更新/定义返回了新的方法 导致渲染（这里是猜测 但是大概应该就是这样），解决这个问题需要用 useCallback 包裹方法即可, 在依赖没有变动的情况下返回相同的方法\r\n\r\n```tsx\r\nconst Outer4FnCallback = useCallback(() => {\r\n  console.log(\"Outer4FnCallback\");\r\n}, []);\r\n```\r\n\r\n### 在组件外 Memo 变量依赖(在父级组件内定义)\r\n\r\n```tsx\r\nconst Outer6V = \"var\";\r\nconst Outer6V = [1,2,3]\r\n\r\n\r\nconst Outer6: React.FC<{ v: string }> = React.memo(function Outer6({ v }) {\r\n  console.log(\"Outer6\", v);\r\n  return (\r\n    <div>\r\n      <div>Outer6 {v}</div>\r\n    </div>\r\n  );\r\n});\r\n```\r\n\r\n1. 字符变量 和默认 Memo 无依赖表现一致\r\n2. 数组/对象 每次父组件更新会重新渲染，返回了新的引用\r\n\r\n如果想定义对象变量又不想触发重新渲染用 useMemo包裹即可\r\n\r\n```tsx\r\nconst Outer6V = useMemo(() => {\r\n\treturn { a: 1 };\r\n}, []);\r\n```\r\n\r\n\r\n\r\n### 在组件外 Memo 无依赖 调用外部 方法\r\n\r\n```tsx\r\nconst Outer7Outer = () => {\r\n  console.log(\"c4Test\");\r\n};\r\n\r\nconst Outer7: React.FC = React.memo(function Outer7({}) {\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  console.log(\"Outer7\");\r\n  return (\r\n    <div>\r\n      <div>Outer7 state {state}</div>\r\n      <button onClick={() => setstate(String(Date.now()))}>C4</button>\r\n      <button onClick={() => Outer7Outer()}>Fn</button>\r\n    </div>\r\n  );\r\n});\r\n```\r\n\r\n1. 父级渲染不影响组件\r\n2. 方法固定引用不重新渲染\r\n\r\n### 在组件外 Memo 依赖传入外部方法\r\n\r\n```tsx\r\nconst Outer7Outer = () => {\r\n  console.log(\"Outer7Outer\");\r\n};\r\n\r\nconst Outer8: React.FC<{ fn: () => void }> = React.memo(function Outer8({\r\n  fn\r\n}) {\r\n  console.log(\"Outer8\");\r\n  return (\r\n    <div>\r\n      <button onClick={() => fn()}>Fn</button>\r\n    </div>\r\n  );\r\n});\r\n```\r\n\r\n1. 同上 没有影响\r\n\r\n### 在组件外 Memo 依赖传入 Object 数据\r\n\r\n```tsx\r\nconst Outer9: React.FC<{ list: object }> = React.memo(function Outer9({\r\n  list\r\n}) {\r\n  console.log(\"Outer9\");\r\n  return (\r\n    <div>\r\n      <div>Outer9 {JSON.stringify(list)}</div>\r\n    </div>\r\n  );\r\n});\r\n```\r\n\r\n1. 表现和默认 Memo 行为一样\r\n\r\n###  在组件外 无 Memo 无依赖 内部 useState 变动\r\n\r\n```tsx\r\nconst Outer10: React.FC = () => {\r\n  console.log(\"Outer10\");\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  return (\r\n    <div>\r\n      <div>Outer10 {state}</div>\r\n      <button onClick={() => setstate(String(Date.now()))}>toggle</button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n1. 表现和默认一致\r\n\r\n### 在组件外 无 Memo 依赖 useState，内部 useMemo\r\n\r\n```tsx\r\nconst Outer11: React.FC<{time1: string}> = ({ time1 }) => {\r\n  console.log(\"Outer11\");\r\n\r\n  const timeMemo = useMemo(() => {\r\n    console.log(\"Outer11 useMemo\");\r\n\r\n    return time1 + \"-----\";\r\n  }, [time1]);\r\n\r\n  return <div>Outer11 {timeMemo}</div>;\r\n};\r\n```\r\n\r\n1. 表现默认一致\r\n2. useMemo 默认执行\r\n\r\n### 在组件外 使用 ahooks useEventEmitter 测试\r\n\r\n```tsx\r\n// Parent\r\nconst focus$ = useEventEmitter();\r\n<button onClick={() => focus$.emit()}>Event</button>\r\n```\r\n\r\n```tsx\r\nconst Outer12: React.FC<{ focus$: EventEmitter<void> }> = React.memo(\r\n  function Outer12({ focus$ }) {\r\n    console.log(\"Outer12\", focus$);\r\n\r\n    focus$.useSubscription(() => {\r\n      console.log(\"Outer12 emit\", focus$);\r\n    });\r\n    return <div>Outer12</div>;\r\n  }\r\n);\r\n\r\nconst Outer13: React.FC<{ focus$: EventEmitter<void> }> = ({ focus$ }) => {\r\n  console.log(\"Outer13\", focus$);\r\n\r\n  focus$.useSubscription(() => {\r\n    console.log(\"Outer13 emit\", focus$);\r\n  });\r\n  return <div>Outer13</div>;\r\n};\r\n```\r\n\r\n```\r\n// 默认\r\nApp Parent \r\nfocus$ \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter12 \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter13 \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\n\r\n// 改变 useState\r\nApp Parent \r\nfocus$ \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter13 \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\n\r\n// 发送事件 emit\r\nOuter12 emit \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter13 emit \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\n\r\n```\r\n\r\n1. 默认执行机制\r\n2. useEventEmitter 事件不会触发渲染机制\r\n\r\n### PureComponent\r\n\r\n```tsx\r\ntype PureProps = {\r\n  time1: string;\r\n};\r\nclass Pure extends React.PureComponent<PureProps> {\r\n\r\n  componentDidMount() {\r\n    console.log('Pure')\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    console.log(\"PureCp---componentDidUpdate\");\r\n  }\r\n\r\n  render() {\r\n    return <h3>PureCp: {this.props.time1}</h3>;\r\n  }\r\n}\r\n```\r\n\r\nhttps://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent\r\n\r\n>`React.PureComponent` 与 [`React.Component`](https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent) 很相似。两者的区别在于 [`React.Component`](https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent) 并未实现 [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate)，而 `React.PureComponent` 中以浅层对比 prop 和 state 的方式来实现了该函数。\r\n>\r\n>如果赋予 React 组件相同的 props 和 state，`render()` 函数会渲染相同的内容，那么在某些情况下使用 `React.PureComponent` 可提高性能。","comments":{"nodes":[]},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"author":{"login":"xiaotiandada","url":"https://github.com/xiaotiandada","avatarUrl":"https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d&v=4"},"html":"<h2 id=\"reactmemo\"><code>React.memo</code></h2>\n<pre class=\"language-react\"><code class=\"language-react\">const MyComponent = React.memo(function MyComponent(props) {\n  /* 使用 props 渲染 */\n});</code></pre><p><a href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactmemo\">https://zh-hans.reactjs.org/docs/react-api.html#reactmemo</a></p>\n<blockquote>\n<p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p>\n<p><code>React.memo</code> 仅检查 props 变更。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <a href=\"https://zh-hans.reactjs.org/docs/hooks-state.html\"><code>useState</code></a>，<a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer\"><code>useReducer</code></a> 或 <a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext\"><code>useContext</code></a> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p>\n<p>...</p>\n</blockquote>\n<p><a href=\"https://codesandbox.io/s/react-memo-qknj7?file=/src/App.tsx\">demo</a> 代码都在这儿</p>\n<h3 id=\"默认情况\">默认情况</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">console.log(\"App Parent\");\n\nconst [time, setTime] = useState<string>(\"\");\nconst [time1, setTime1] = useState<string>(\"\");\n\n<div>\n  <div>Parent</div>\n  <ul>\n    <li>time: {time}</li>\n    <li>time1: {time1}</li>\n  </ul>\n  <button onClick={() => setTime(\"1111\")}>toggle</button>\n  <button onClick={() => setTime1(String(Date.now()))}>toggle1</button>\n  <button onClick={() => setTime1(\"0000000000\")}>toggle1</button>\n</div></code></pre><ol>\n<li>默认执行 输出 <code>App Parent</code> 一次</li>\n<li>组件内 useState 变动则会重新渲染一次</li>\n</ol>\n<h3 id=\"默认组件-在组件内\">默认组件 在组件内</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">  const child1: React.FC = () => {\n    console.log(\"child1\");\n    return (\n      <div>\n        <div>child1</div>\n        <button onClick={() => setTime1(\"child1\")}>toggle</button>\n        <button onClick={() => setTime1(String(Date.now()))}>toggle</button>\n      </div>\n    );\n  };</code></pre><ol>\n<li>父组件渲染一次 child1 也渲染一次</li>\n<li>父组件 useState 改动 父组件和 child1 渲染一次</li>\n<li>child1 组件 useState 改动 父组件和 child1 渲染一次</li>\n</ol>\n<h3 id=\"默认组件-使用方式\">默认组件 使用方式</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\"><div>{Child1()}</div>\n<Child2 /></code></pre><pre><code>App Parent \nChild1 \nChild2 \n\nApp Parent \nChild1 </code></pre><ol>\n<li>表现基本与上面一致</li>\n<li>第一次 都渲染，后面 修改相同 useState 执行 Child1，修改不相同 useState 执行  Child1 Child2</li>\n</ol>\n<h3 id=\"memo-在组件内\">Memo 在组件内</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Child3: React.FC = React.memo(function Child3() {\n  console.log(\"Child3\");\n  return (\n    <div>\n      <div>Child2</div>\n      <div>{time}</div>\n      <div>{time1}</div>\n    </div>\n  );\n});</code></pre><ol>\n<li>无效 表现和默认一致</li>\n</ol>\n<h3 id=\"在组件内-无依赖-修改-usestate\">在组件内 无依赖 修改 useState</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">  const Child4: React.FC = () => {\n    console.log(\"Child4\");\n    const [state, setstate] = useState(\"\");\n\n    return (\n      <div>\n        <div>{state}</div>\n        <button onClick={() => setstate(String(Date.now()))}>toggle</button>\n      </div>\n    );\n  };</code></pre><ol>\n<li>只渲染当前组件</li>\n</ol>\n<h3 id=\"在组件外-默认组件-无依赖\">在组件外 默认组件 无依赖</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer1 = () => {\n  console.log(\"Outer1\");\n  return <div>Outer1</div>;\n};</code></pre><ol>\n<li>表现和默认一致</li>\n</ol>\n<pre><code>App Parent \nOuter1 </code></pre><h3 id=\"在组件外-momo-无依赖\">在组件外 Momo 无依赖</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer2 = React.memo(function Outer2() {\n  console.log(\"Outer2\");\n  return <div>Outer2</div>;\n});</code></pre><pre><code>\nApp Parent \nOuter1 \nOuter2 \nApp Parent \nOuter1\nApp Parent \nOuter1 </code></pre><ol>\n<li>只会渲染一次 父级 useState 改变不受影响</li>\n</ol>\n<h3 id=\"在组件外-memo-usestate-依赖\">在组件外 Memo useState 依赖</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer3: React.FC<{ time1: string }> = React.memo(function Outer3({\n  time1\n}) {\n  console.log(\"Outer3 time1\", time1);\n  return <div>Outer3 {time1}</div>;\n});</code></pre><pre><code>\nApp Parent \nOuter1 \nOuter2 \nOuter3 time1 \"\" \nApp Parent \nOuter1 \nOuter3 time1 1630983888577 \nApp Parent \nOuter1 \nOuter3 time1 1630983892146 </code></pre><ol>\n<li>默认执行一次</li>\n<li>依赖外 useState 变动不渲染</li>\n<li>依赖 useState 变动渲染一次</li>\n</ol>\n<h3 id=\"在组件外-memo-usestate-依赖-，-内部拥有-usestate\">在组件外 Memo useState 依赖 ， 内部拥有 useState</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer4: React.FC<{ time1: string }> = React.memo(function Outer4({\n  time1\n}) {\n  const [state, setstate] = useState(\"\");\n\n  console.log(\"Outer4\");\n  return (\n    <div>\n      <div>Outer4 state {state}</div>\n      <div>Outer4 time1 {time1}</div>\n      <button onClick={() => setstate(String(Date.now()))}>Toggle</button>\n    </div>\n  );\n});</code></pre><pre><code>App Parent \nOuter1 \nOuter2 \nOuter3 time1 \"\" \nOuter4 \nApp Parent \nOuter1 \nApp Parent \nOuter1 \nOuter3 time1 1630984999782 \nOuter4 \nOuter4 </code></pre><ol>\n<li>同上</li>\n<li>内部 useState 变动渲染一次</li>\n</ol>\n<h3 id=\"在组件外-memo-function-依赖-在父级组件内定义\">在组件外 Memo function 依赖 (在父级组件内定义)</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer5: React.FC<{ fn: () => void }> = React.memo(function Outer5({\n  fn\n}) {\n  const [state, setstate] = useState(\"\");\n\n  console.log(\"Outer5\");\n  return (\n    <div>\n      <div>Outer5 state {state}</div>\n      <button onClick={() => setstate(String(Date.now()))}>Toggle</button>\n      <button onClick={() => fn()}>Fn</button>\n    </div>\n  );\n});\n\nconst Outer4Fn = () => {\n  console.log(\"Outer4Fn\");\n};</code></pre><pre><code>\nApp Parent \nOuter1 \nOuter2 \nOuter3 time1 \"\" \nOuter4 \nOuter5 \n\nApp Parent \nOuter1 \nOuter5 \n\nApp Parent \nOuter1 \nOuter3 time1 1630985278410 \nOuter4 \nOuter5 \n\nApp Parent \nOuter1 \nOuter3 time1 1630985281298 \nOuter4 \nOuter5 \n\nOuter4Fn \nOuter4Fn </code></pre><ol>\n<li>默认渲染一次</li>\n<li>修改父级组件 useState 渲染一次</li>\n<li>执行 fn 不渲染</li>\n</ol>\n<p>应该是父级渲染导致方法重新更新/定义返回了新的方法 导致渲染（这里是猜测 但是大概应该就是这样），解决这个问题需要用 useCallback 包裹方法即可, 在依赖没有变动的情况下返回相同的方法</p>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer4FnCallback = useCallback(() => {\n  console.log(\"Outer4FnCallback\");\n}, []);</code></pre><h3 id=\"在组件外-memo-变量依赖在父级组件内定义\">在组件外 Memo 变量依赖(在父级组件内定义)</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer6V = \"var\";\nconst Outer6V = [1,2,3]\n\n\nconst Outer6: React.FC<{ v: string }> = React.memo(function Outer6({ v }) {\n  console.log(\"Outer6\", v);\n  return (\n    <div>\n      <div>Outer6 {v}</div>\n    </div>\n  );\n});</code></pre><ol>\n<li>字符变量 和默认 Memo 无依赖表现一致</li>\n<li>数组/对象 每次父组件更新会重新渲染，返回了新的引用</li>\n</ol>\n<p>如果想定义对象变量又不想触发重新渲染用 useMemo包裹即可</p>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer6V = useMemo(() => {\n    return { a: 1 };\n}, []);</code></pre><h3 id=\"在组件外-memo-无依赖-调用外部-方法\">在组件外 Memo 无依赖 调用外部 方法</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer7Outer = () => {\n  console.log(\"c4Test\");\n};\n\nconst Outer7: React.FC = React.memo(function Outer7({}) {\n  const [state, setstate] = useState(\"\");\n\n  console.log(\"Outer7\");\n  return (\n    <div>\n      <div>Outer7 state {state}</div>\n      <button onClick={() => setstate(String(Date.now()))}>C4</button>\n      <button onClick={() => Outer7Outer()}>Fn</button>\n    </div>\n  );\n});</code></pre><ol>\n<li>父级渲染不影响组件</li>\n<li>方法固定引用不重新渲染</li>\n</ol>\n<h3 id=\"在组件外-memo-依赖传入外部方法\">在组件外 Memo 依赖传入外部方法</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer7Outer = () => {\n  console.log(\"Outer7Outer\");\n};\n\nconst Outer8: React.FC<{ fn: () => void }> = React.memo(function Outer8({\n  fn\n}) {\n  console.log(\"Outer8\");\n  return (\n    <div>\n      <button onClick={() => fn()}>Fn</button>\n    </div>\n  );\n});</code></pre><ol>\n<li>同上 没有影响</li>\n</ol>\n<h3 id=\"在组件外-memo-依赖传入-object-数据\">在组件外 Memo 依赖传入 Object 数据</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer9: React.FC<{ list: object }> = React.memo(function Outer9({\n  list\n}) {\n  console.log(\"Outer9\");\n  return (\n    <div>\n      <div>Outer9 {JSON.stringify(list)}</div>\n    </div>\n  );\n});</code></pre><ol>\n<li>表现和默认 Memo 行为一样</li>\n</ol>\n<h3 id=\"在组件外-无-memo-无依赖-内部-usestate-变动\">在组件外 无 Memo 无依赖 内部 useState 变动</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer10: React.FC = () => {\n  console.log(\"Outer10\");\n  const [state, setstate] = useState(\"\");\n\n  return (\n    <div>\n      <div>Outer10 {state}</div>\n      <button onClick={() => setstate(String(Date.now()))}>toggle</button>\n    </div>\n  );\n};</code></pre><ol>\n<li>表现和默认一致</li>\n</ol>\n<h3 id=\"在组件外-无-memo-依赖-usestate，内部-usememo\">在组件外 无 Memo 依赖 useState，内部 useMemo</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer11: React.FC<{time1: string}> = ({ time1 }) => {\n  console.log(\"Outer11\");\n\n  const timeMemo = useMemo(() => {\n    console.log(\"Outer11 useMemo\");\n\n    return time1 + \"-----\";\n  }, [time1]);\n\n  return <div>Outer11 {timeMemo}</div>;\n};</code></pre><ol>\n<li>表现默认一致</li>\n<li>useMemo 默认执行</li>\n</ol>\n<h3 id=\"在组件外-使用-ahooks-useeventemitter-测试\">在组件外 使用 ahooks useEventEmitter 测试</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">// Parent\nconst focus$ = useEventEmitter();\n<button onClick={() => focus$.emit()}>Event</button></code></pre><pre class=\"language-tsx\"><code class=\"language-tsx\">const Outer12: React.FC<{ focus$: EventEmitter<void> }> = React.memo(\n  function Outer12({ focus$ }) {\n    console.log(\"Outer12\", focus$);\n\n    focus$.useSubscription(() => {\n      console.log(\"Outer12 emit\", focus$);\n    });\n    return <div>Outer12</div>;\n  }\n);\n\nconst Outer13: React.FC<{ focus$: EventEmitter<void> }> = ({ focus$ }) => {\n  console.log(\"Outer13\", focus$);\n\n  focus$.useSubscription(() => {\n    console.log(\"Outer13 emit\", focus$);\n  });\n  return <div>Outer13</div>;\n};</code></pre><pre><code>// 默认\nApp Parent \nfocus$ \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter12 \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter13 \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\n\n// 改变 useState\nApp Parent \nfocus$ \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter13 \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\n\n// 发送事件 emit\nOuter12 emit \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter13 emit \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\n</code></pre><ol>\n<li>默认执行机制</li>\n<li>useEventEmitter 事件不会触发渲染机制</li>\n</ol>\n<h3 id=\"purecomponent\">PureComponent</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">type PureProps = {\n  time1: string;\n};\nclass Pure extends React.PureComponent<PureProps> {\n\n  componentDidMount() {\n    console.log('Pure')\n  }\n\n  componentDidUpdate() {\n    console.log(\"PureCp---componentDidUpdate\");\n  }\n\n  render() {\n    return <h3>PureCp: {this.props.time1}</h3>;\n  }\n}</code></pre><p><a href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent\">https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent</a></p>\n<blockquote>\n<p><code>React.PureComponent</code> 与 <a href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent\"><code>React.Component</code></a> 很相似。两者的区别在于 <a href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent\"><code>React.Component</code></a> 并未实现 <a href=\"https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate\"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。</p>\n<p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p>\n</blockquote>\n","attributes":{}},"themeConfig":{"title":"Blog(issues)","links":[{"title":"GitHub","url":"https://github.com/xiaotiandada/blog"},{"title":"Twitter","url":"https://twitter.com/XiaoTianIsMe"}]}},"__N_SSG":true}