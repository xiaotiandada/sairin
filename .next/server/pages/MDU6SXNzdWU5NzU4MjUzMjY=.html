<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>React.memo 学习 - Blog(issues)</title><meta property="og:type" content="artical"/><meta property="og:title" content="React.memo 学习"/><meta property="og:image" content="
        https://og-image.vercel.app/React.memo 学习.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fvercel-triangle-black.svg
      "/><meta property="article:published_time" content="2021-08-20T18:19:13Z"/><meta property="article:author" content="xiaotiandada"/><meta name="twitter:card" content="React.memo 学习"/><meta name="twitter:title" content="React.memo 学习"/><meta name="twitter:image" content="
        https://og-image.vercel.app/React.memo 学习.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fvercel-triangle-black.svg
      "/><meta name="next-head-count" content="4"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&amp;display=swap" rel="stylesheet"/><link rel="preload" href="/_next/static/css/b78bfc7021c6877d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b78bfc7021c6877d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-2190439a97dca295.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2aac380799256b7f.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...path%5D-e0b96643230aac68.js" defer=""></script><script src="/_next/static/YPEk3V-eoVeml18YoUSCM/_buildManifest.js" defer=""></script><script src="/_next/static/YPEk3V-eoVeml18YoUSCM/_ssgManifest.js" defer=""></script><script src="/_next/static/YPEk3V-eoVeml18YoUSCM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><div class="container mx-auto mt-24 max-w-2xl px-4 sm:px-0"><div><div class="flex my-8 font-bold"><a href="/">Blog(issues)</a></div></div><div class="mb-8"><div class="text-3xl font-medium">React.memo 学习</div><div class="flex mt-4 items-center gap-2"><img class="w-8 h-8 rounded-full" src="https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d&amp;v=4"/><a target="_blank" href="https://github.com/xiaotiandada">xiaotiandada</a><a class="underline text-sm" target="_blank" href="https://github.com/xiaotiandada/blog/issues/84">View on GitHub</a></div><div class="my-8"><div class="flex gap-4 flex-wrap"></div></div></div><div class="post-body"><h2 id="reactmemo"><code>React.memo</code></h2>
<pre class="language-react"><code class="language-react">const MyComponent = React.memo(function MyComponent(props) {
  /* 使用 props 渲染 */
});</code></pre><p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">https://zh-hans.reactjs.org/docs/react-api.html#reactmemo</a></p>
<blockquote>
<p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p>
<p><code>React.memo</code> 仅检查 props 变更。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <a href="https://zh-hans.reactjs.org/docs/hooks-state.html"><code>useState</code></a>，<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext</code></a> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p>
<p>...</p>
</blockquote>
<p><a href="https://codesandbox.io/s/react-memo-qknj7?file=/src/App.tsx">demo</a> 代码都在这儿</p>
<h3 id="默认情况">默认情况</h3>
<pre class="language-tsx"><code class="language-tsx">console.log("App Parent");

const [time, setTime] = useState<string>("");
const [time1, setTime1] = useState<string>("");

<div>
  <div>Parent</div>
  <ul>
    <li>time: {time}</li>
    <li>time1: {time1}</li>
  </ul>
  <button onClick={() => setTime("1111")}>toggle</button>
  <button onClick={() => setTime1(String(Date.now()))}>toggle1</button>
  <button onClick={() => setTime1("0000000000")}>toggle1</button>
</div></code></pre><ol>
<li>默认执行 输出 <code>App Parent</code> 一次</li>
<li>组件内 useState 变动则会重新渲染一次</li>
</ol>
<h3 id="默认组件-在组件内">默认组件 在组件内</h3>
<pre class="language-tsx"><code class="language-tsx">  const child1: React.FC = () => {
    console.log("child1");
    return (
      <div>
        <div>child1</div>
        <button onClick={() => setTime1("child1")}>toggle</button>
        <button onClick={() => setTime1(String(Date.now()))}>toggle</button>
      </div>
    );
  };</code></pre><ol>
<li>父组件渲染一次 child1 也渲染一次</li>
<li>父组件 useState 改动 父组件和 child1 渲染一次</li>
<li>child1 组件 useState 改动 父组件和 child1 渲染一次</li>
</ol>
<h3 id="默认组件-使用方式">默认组件 使用方式</h3>
<pre class="language-tsx"><code class="language-tsx"><div>{Child1()}</div>
<Child2 /></code></pre><pre><code>App Parent 
Child1 
Child2 

App Parent 
Child1 </code></pre><ol>
<li>表现基本与上面一致</li>
<li>第一次 都渲染，后面 修改相同 useState 执行 Child1，修改不相同 useState 执行  Child1 Child2</li>
</ol>
<h3 id="memo-在组件内">Memo 在组件内</h3>
<pre class="language-tsx"><code class="language-tsx">const Child3: React.FC = React.memo(function Child3() {
  console.log("Child3");
  return (
    <div>
      <div>Child2</div>
      <div>{time}</div>
      <div>{time1}</div>
    </div>
  );
});</code></pre><ol>
<li>无效 表现和默认一致</li>
</ol>
<h3 id="在组件内-无依赖-修改-usestate">在组件内 无依赖 修改 useState</h3>
<pre class="language-tsx"><code class="language-tsx">  const Child4: React.FC = () => {
    console.log("Child4");
    const [state, setstate] = useState("");

    return (
      <div>
        <div>{state}</div>
        <button onClick={() => setstate(String(Date.now()))}>toggle</button>
      </div>
    );
  };</code></pre><ol>
<li>只渲染当前组件</li>
</ol>
<h3 id="在组件外-默认组件-无依赖">在组件外 默认组件 无依赖</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer1 = () => {
  console.log("Outer1");
  return <div>Outer1</div>;
};</code></pre><ol>
<li>表现和默认一致</li>
</ol>
<pre><code>App Parent 
Outer1 </code></pre><h3 id="在组件外-momo-无依赖">在组件外 Momo 无依赖</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer2 = React.memo(function Outer2() {
  console.log("Outer2");
  return <div>Outer2</div>;
});</code></pre><pre><code>
App Parent 
Outer1 
Outer2 
App Parent 
Outer1
App Parent 
Outer1 </code></pre><ol>
<li>只会渲染一次 父级 useState 改变不受影响</li>
</ol>
<h3 id="在组件外-memo-usestate-依赖">在组件外 Memo useState 依赖</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer3: React.FC<{ time1: string }> = React.memo(function Outer3({
  time1
}) {
  console.log("Outer3 time1", time1);
  return <div>Outer3 {time1}</div>;
});</code></pre><pre><code>
App Parent 
Outer1 
Outer2 
Outer3 time1 "" 
App Parent 
Outer1 
Outer3 time1 1630983888577 
App Parent 
Outer1 
Outer3 time1 1630983892146 </code></pre><ol>
<li>默认执行一次</li>
<li>依赖外 useState 变动不渲染</li>
<li>依赖 useState 变动渲染一次</li>
</ol>
<h3 id="在组件外-memo-usestate-依赖-，-内部拥有-usestate">在组件外 Memo useState 依赖 ， 内部拥有 useState</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer4: React.FC<{ time1: string }> = React.memo(function Outer4({
  time1
}) {
  const [state, setstate] = useState("");

  console.log("Outer4");
  return (
    <div>
      <div>Outer4 state {state}</div>
      <div>Outer4 time1 {time1}</div>
      <button onClick={() => setstate(String(Date.now()))}>Toggle</button>
    </div>
  );
});</code></pre><pre><code>App Parent 
Outer1 
Outer2 
Outer3 time1 "" 
Outer4 
App Parent 
Outer1 
App Parent 
Outer1 
Outer3 time1 1630984999782 
Outer4 
Outer4 </code></pre><ol>
<li>同上</li>
<li>内部 useState 变动渲染一次</li>
</ol>
<h3 id="在组件外-memo-function-依赖-在父级组件内定义">在组件外 Memo function 依赖 (在父级组件内定义)</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer5: React.FC<{ fn: () => void }> = React.memo(function Outer5({
  fn
}) {
  const [state, setstate] = useState("");

  console.log("Outer5");
  return (
    <div>
      <div>Outer5 state {state}</div>
      <button onClick={() => setstate(String(Date.now()))}>Toggle</button>
      <button onClick={() => fn()}>Fn</button>
    </div>
  );
});

const Outer4Fn = () => {
  console.log("Outer4Fn");
};</code></pre><pre><code>
App Parent 
Outer1 
Outer2 
Outer3 time1 "" 
Outer4 
Outer5 

App Parent 
Outer1 
Outer5 

App Parent 
Outer1 
Outer3 time1 1630985278410 
Outer4 
Outer5 

App Parent 
Outer1 
Outer3 time1 1630985281298 
Outer4 
Outer5 

Outer4Fn 
Outer4Fn </code></pre><ol>
<li>默认渲染一次</li>
<li>修改父级组件 useState 渲染一次</li>
<li>执行 fn 不渲染</li>
</ol>
<p>应该是父级渲染导致方法重新更新/定义返回了新的方法 导致渲染（这里是猜测 但是大概应该就是这样），解决这个问题需要用 useCallback 包裹方法即可, 在依赖没有变动的情况下返回相同的方法</p>
<pre class="language-tsx"><code class="language-tsx">const Outer4FnCallback = useCallback(() => {
  console.log("Outer4FnCallback");
}, []);</code></pre><h3 id="在组件外-memo-变量依赖在父级组件内定义">在组件外 Memo 变量依赖(在父级组件内定义)</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer6V = "var";
const Outer6V = [1,2,3]


const Outer6: React.FC<{ v: string }> = React.memo(function Outer6({ v }) {
  console.log("Outer6", v);
  return (
    <div>
      <div>Outer6 {v}</div>
    </div>
  );
});</code></pre><ol>
<li>字符变量 和默认 Memo 无依赖表现一致</li>
<li>数组/对象 每次父组件更新会重新渲染，返回了新的引用</li>
</ol>
<p>如果想定义对象变量又不想触发重新渲染用 useMemo包裹即可</p>
<pre class="language-tsx"><code class="language-tsx">const Outer6V = useMemo(() => {
    return { a: 1 };
}, []);</code></pre><h3 id="在组件外-memo-无依赖-调用外部-方法">在组件外 Memo 无依赖 调用外部 方法</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer7Outer = () => {
  console.log("c4Test");
};

const Outer7: React.FC = React.memo(function Outer7({}) {
  const [state, setstate] = useState("");

  console.log("Outer7");
  return (
    <div>
      <div>Outer7 state {state}</div>
      <button onClick={() => setstate(String(Date.now()))}>C4</button>
      <button onClick={() => Outer7Outer()}>Fn</button>
    </div>
  );
});</code></pre><ol>
<li>父级渲染不影响组件</li>
<li>方法固定引用不重新渲染</li>
</ol>
<h3 id="在组件外-memo-依赖传入外部方法">在组件外 Memo 依赖传入外部方法</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer7Outer = () => {
  console.log("Outer7Outer");
};

const Outer8: React.FC<{ fn: () => void }> = React.memo(function Outer8({
  fn
}) {
  console.log("Outer8");
  return (
    <div>
      <button onClick={() => fn()}>Fn</button>
    </div>
  );
});</code></pre><ol>
<li>同上 没有影响</li>
</ol>
<h3 id="在组件外-memo-依赖传入-object-数据">在组件外 Memo 依赖传入 Object 数据</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer9: React.FC<{ list: object }> = React.memo(function Outer9({
  list
}) {
  console.log("Outer9");
  return (
    <div>
      <div>Outer9 {JSON.stringify(list)}</div>
    </div>
  );
});</code></pre><ol>
<li>表现和默认 Memo 行为一样</li>
</ol>
<h3 id="在组件外-无-memo-无依赖-内部-usestate-变动">在组件外 无 Memo 无依赖 内部 useState 变动</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer10: React.FC = () => {
  console.log("Outer10");
  const [state, setstate] = useState("");

  return (
    <div>
      <div>Outer10 {state}</div>
      <button onClick={() => setstate(String(Date.now()))}>toggle</button>
    </div>
  );
};</code></pre><ol>
<li>表现和默认一致</li>
</ol>
<h3 id="在组件外-无-memo-依赖-usestate，内部-usememo">在组件外 无 Memo 依赖 useState，内部 useMemo</h3>
<pre class="language-tsx"><code class="language-tsx">const Outer11: React.FC<{time1: string}> = ({ time1 }) => {
  console.log("Outer11");

  const timeMemo = useMemo(() => {
    console.log("Outer11 useMemo");

    return time1 + "-----";
  }, [time1]);

  return <div>Outer11 {timeMemo}</div>;
};</code></pre><ol>
<li>表现默认一致</li>
<li>useMemo 默认执行</li>
</ol>
<h3 id="在组件外-使用-ahooks-useeventemitter-测试">在组件外 使用 ahooks useEventEmitter 测试</h3>
<pre class="language-tsx"><code class="language-tsx">// Parent
const focus$ = useEventEmitter();
<button onClick={() => focus$.emit()}>Event</button></code></pre><pre class="language-tsx"><code class="language-tsx">const Outer12: React.FC<{ focus$: EventEmitter<void> }> = React.memo(
  function Outer12({ focus$ }) {
    console.log("Outer12", focus$);

    focus$.useSubscription(() => {
      console.log("Outer12 emit", focus$);
    });
    return <div>Outer12</div>;
  }
);

const Outer13: React.FC<{ focus$: EventEmitter<void> }> = ({ focus$ }) => {
  console.log("Outer13", focus$);

  focus$.useSubscription(() => {
    console.log("Outer13 emit", focus$);
  });
  return <div>Outer13</div>;
};</code></pre><pre><code>// 默认
App Parent 
focus$ 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer12 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer13 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}

// 改变 useState
App Parent 
focus$ 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer13 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}

// 发送事件 emit
Outer12 emit 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer13 emit 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
</code></pre><ol>
<li>默认执行机制</li>
<li>useEventEmitter 事件不会触发渲染机制</li>
</ol>
<h3 id="purecomponent">PureComponent</h3>
<pre class="language-tsx"><code class="language-tsx">type PureProps = {
  time1: string;
};
class Pure extends React.PureComponent<PureProps> {

  componentDidMount() {
    console.log('Pure')
  }

  componentDidUpdate() {
    console.log("PureCp---componentDidUpdate");
  }

  render() {
    return <h3>PureCp: {this.props.time1}</h3>;
  }
}</code></pre><p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent">https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent</a></p>
<blockquote>
<p><code>React.PureComponent</code> 与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a> 很相似。两者的区别在于 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a> 并未实现 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。</p>
<p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p>
</blockquote>
</div><hr class="my-12"/><div class="font-sans"><div class="mb-12"><a target="_blank" href="https://github.com/xiaotiandada/blog/issues/84" class="font-medium border border-gray-700 hover:bg-gray-700 hover:text-gray-100 transition-all text-gray-700 text-sm rounded px-4 py-2">Add comment</a></div></div><div class="my-12"><div class="text-sm">Powered by <a class="underline" target="_blank" href="https://github.com/djyde/sairin">Sairin</a></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"MDU6SXNzdWU5NzU4MjUzMjY=","url":"https://github.com/xiaotiandada/blog/issues/84","title":"React.memo 学习","updatedAt":"2022-01-05T08:38:30Z","createdAt":"2021-08-20T18:19:13Z","body":"## `React.memo`\r\n\r\n```react\r\nconst MyComponent = React.memo(function MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n});\r\n```\r\n\r\nhttps://zh-hans.reactjs.org/docs/react-api.html#reactmemo\r\n\r\n\u003e如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 `React.memo` 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\r\n\u003e\r\n\u003e`React.memo` 仅检查 props 变更。如果函数组件被 `React.memo` 包裹，且其实现中拥有 [`useState`](https://zh-hans.reactjs.org/docs/hooks-state.html)，[`useReducer`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer) 或 [`useContext`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext) 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。\r\n\u003e\r\n\u003e...\r\n\r\n[demo](https://codesandbox.io/s/react-memo-qknj7?file=/src/App.tsx) 代码都在这儿\r\n\r\n\r\n\r\n### 默认情况\r\n\r\n```tsx\r\nconsole.log(\"App Parent\");\r\n\r\nconst [time, setTime] = useState\u003cstring\u003e(\"\");\r\nconst [time1, setTime1] = useState\u003cstring\u003e(\"\");\r\n\r\n\u003cdiv\u003e\r\n  \u003cdiv\u003eParent\u003c/div\u003e\r\n  \u003cul\u003e\r\n    \u003cli\u003etime: {time}\u003c/li\u003e\r\n    \u003cli\u003etime1: {time1}\u003c/li\u003e\r\n  \u003c/ul\u003e\r\n  \u003cbutton onClick={() =\u003e setTime(\"1111\")}\u003etoggle\u003c/button\u003e\r\n  \u003cbutton onClick={() =\u003e setTime1(String(Date.now()))}\u003etoggle1\u003c/button\u003e\r\n  \u003cbutton onClick={() =\u003e setTime1(\"0000000000\")}\u003etoggle1\u003c/button\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n1. 默认执行 输出 ``App Parent`` 一次\r\n2. 组件内 useState 变动则会重新渲染一次\r\n\r\n\r\n\r\n### 默认组件 在组件内\r\n\r\n```tsx\r\n  const child1: React.FC = () =\u003e {\r\n    console.log(\"child1\");\r\n    return (\r\n      \u003cdiv\u003e\r\n        \u003cdiv\u003echild1\u003c/div\u003e\r\n        \u003cbutton onClick={() =\u003e setTime1(\"child1\")}\u003etoggle\u003c/button\u003e\r\n        \u003cbutton onClick={() =\u003e setTime1(String(Date.now()))}\u003etoggle\u003c/button\u003e\r\n      \u003c/div\u003e\r\n    );\r\n  };\r\n```\r\n\r\n1. 父组件渲染一次 child1 也渲染一次\r\n2. 父组件 useState 改动 父组件和 child1 渲染一次\r\n3. child1 组件 useState 改动 父组件和 child1 渲染一次\r\n\r\n\r\n\r\n### 默认组件 使用方式\r\n\r\n```tsx\r\n\u003cdiv\u003e{Child1()}\u003c/div\u003e\r\n\u003cChild2 /\u003e\r\n```\r\n\r\n```\r\nApp Parent \r\nChild1 \r\nChild2 \r\n\r\nApp Parent \r\nChild1 \r\n```\r\n\r\n1. 表现基本与上面一致\r\n2. 第一次 都渲染，后面 修改相同 useState 执行 Child1，修改不相同 useState 执行  Child1 Child2\r\n\r\n\r\n\r\n### Memo 在组件内\r\n\r\n```tsx\r\nconst Child3: React.FC = React.memo(function Child3() {\r\n  console.log(\"Child3\");\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003eChild2\u003c/div\u003e\r\n      \u003cdiv\u003e{time}\u003c/div\u003e\r\n      \u003cdiv\u003e{time1}\u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n1. 无效 表现和默认一致\r\n\r\n\r\n\r\n### 在组件内 无依赖 修改 useState\r\n\r\n```tsx\r\n  const Child4: React.FC = () =\u003e {\r\n    console.log(\"Child4\");\r\n    const [state, setstate] = useState(\"\");\r\n\r\n    return (\r\n      \u003cdiv\u003e\r\n        \u003cdiv\u003e{state}\u003c/div\u003e\r\n        \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003etoggle\u003c/button\u003e\r\n      \u003c/div\u003e\r\n    );\r\n  };\r\n```\r\n\r\n1. 只渲染当前组件\r\n\r\n### 在组件外 默认组件 无依赖\r\n\r\n```tsx\r\nconst Outer1 = () =\u003e {\r\n  console.log(\"Outer1\");\r\n  return \u003cdiv\u003eOuter1\u003c/div\u003e;\r\n};\r\n```\r\n\r\n1. 表现和默认一致\r\n\r\n```\r\nApp Parent \r\nOuter1 \r\n```\r\n\r\n\r\n\r\n### 在组件外 Momo 无依赖\r\n\r\n```tsx\r\nconst Outer2 = React.memo(function Outer2() {\r\n  console.log(\"Outer2\");\r\n  return \u003cdiv\u003eOuter2\u003c/div\u003e;\r\n});\r\n```\r\n\r\n```\r\n\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nApp Parent \r\nOuter1\r\nApp Parent \r\nOuter1 \r\n```\r\n\r\n1. 只会渲染一次 父级 useState 改变不受影响\r\n\r\n### 在组件外 Memo useState 依赖\r\n\r\n```tsx\r\nconst Outer3: React.FC\u003c{ time1: string }\u003e = React.memo(function Outer3({\r\n  time1\r\n}) {\r\n  console.log(\"Outer3 time1\", time1);\r\n  return \u003cdiv\u003eOuter3 {time1}\u003c/div\u003e;\r\n});\r\n```\r\n\r\n```\r\n\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nOuter3 time1 \"\" \r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630983888577 \r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630983892146 \r\n```\r\n\r\n1. 默认执行一次\r\n2. 依赖外 useState 变动不渲染\r\n3. 依赖 useState 变动渲染一次\r\n\r\n### 在组件外 Memo useState 依赖 ， 内部拥有 useState\r\n\r\n```tsx\r\nconst Outer4: React.FC\u003c{ time1: string }\u003e = React.memo(function Outer4({\r\n  time1\r\n}) {\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  console.log(\"Outer4\");\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003eOuter4 state {state}\u003c/div\u003e\r\n      \u003cdiv\u003eOuter4 time1 {time1}\u003c/div\u003e\r\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003eToggle\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n```\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nOuter3 time1 \"\" \r\nOuter4 \r\nApp Parent \r\nOuter1 \r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630984999782 \r\nOuter4 \r\nOuter4 \r\n```\r\n\r\n1. 同上\r\n2. 内部 useState 变动渲染一次\r\n\r\n### 在组件外 Memo function 依赖 (在父级组件内定义)\r\n\r\n```tsx\r\nconst Outer5: React.FC\u003c{ fn: () =\u003e void }\u003e = React.memo(function Outer5({\r\n  fn\r\n}) {\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  console.log(\"Outer5\");\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003eOuter5 state {state}\u003c/div\u003e\r\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003eToggle\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e fn()}\u003eFn\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\nconst Outer4Fn = () =\u003e {\r\n  console.log(\"Outer4Fn\");\r\n};\r\n```\r\n\r\n```\r\n\r\nApp Parent \r\nOuter1 \r\nOuter2 \r\nOuter3 time1 \"\" \r\nOuter4 \r\nOuter5 \r\n\r\nApp Parent \r\nOuter1 \r\nOuter5 \r\n\r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630985278410 \r\nOuter4 \r\nOuter5 \r\n\r\nApp Parent \r\nOuter1 \r\nOuter3 time1 1630985281298 \r\nOuter4 \r\nOuter5 \r\n\r\nOuter4Fn \r\nOuter4Fn \r\n```\r\n\r\n1. 默认渲染一次\r\n2. 修改父级组件 useState 渲染一次\r\n3. 执行 fn 不渲染\r\n\r\n应该是父级渲染导致方法重新更新/定义返回了新的方法 导致渲染（这里是猜测 但是大概应该就是这样），解决这个问题需要用 useCallback 包裹方法即可, 在依赖没有变动的情况下返回相同的方法\r\n\r\n```tsx\r\nconst Outer4FnCallback = useCallback(() =\u003e {\r\n  console.log(\"Outer4FnCallback\");\r\n}, []);\r\n```\r\n\r\n### 在组件外 Memo 变量依赖(在父级组件内定义)\r\n\r\n```tsx\r\nconst Outer6V = \"var\";\r\nconst Outer6V = [1,2,3]\r\n\r\n\r\nconst Outer6: React.FC\u003c{ v: string }\u003e = React.memo(function Outer6({ v }) {\r\n  console.log(\"Outer6\", v);\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003eOuter6 {v}\u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n1. 字符变量 和默认 Memo 无依赖表现一致\r\n2. 数组/对象 每次父组件更新会重新渲染，返回了新的引用\r\n\r\n如果想定义对象变量又不想触发重新渲染用 useMemo包裹即可\r\n\r\n```tsx\r\nconst Outer6V = useMemo(() =\u003e {\r\n\treturn { a: 1 };\r\n}, []);\r\n```\r\n\r\n\r\n\r\n### 在组件外 Memo 无依赖 调用外部 方法\r\n\r\n```tsx\r\nconst Outer7Outer = () =\u003e {\r\n  console.log(\"c4Test\");\r\n};\r\n\r\nconst Outer7: React.FC = React.memo(function Outer7({}) {\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  console.log(\"Outer7\");\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003eOuter7 state {state}\u003c/div\u003e\r\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003eC4\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e Outer7Outer()}\u003eFn\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n1. 父级渲染不影响组件\r\n2. 方法固定引用不重新渲染\r\n\r\n### 在组件外 Memo 依赖传入外部方法\r\n\r\n```tsx\r\nconst Outer7Outer = () =\u003e {\r\n  console.log(\"Outer7Outer\");\r\n};\r\n\r\nconst Outer8: React.FC\u003c{ fn: () =\u003e void }\u003e = React.memo(function Outer8({\r\n  fn\r\n}) {\r\n  console.log(\"Outer8\");\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e fn()}\u003eFn\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n1. 同上 没有影响\r\n\r\n### 在组件外 Memo 依赖传入 Object 数据\r\n\r\n```tsx\r\nconst Outer9: React.FC\u003c{ list: object }\u003e = React.memo(function Outer9({\r\n  list\r\n}) {\r\n  console.log(\"Outer9\");\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003eOuter9 {JSON.stringify(list)}\u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n1. 表现和默认 Memo 行为一样\r\n\r\n###  在组件外 无 Memo 无依赖 内部 useState 变动\r\n\r\n```tsx\r\nconst Outer10: React.FC = () =\u003e {\r\n  console.log(\"Outer10\");\r\n  const [state, setstate] = useState(\"\");\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003eOuter10 {state}\u003c/div\u003e\r\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003etoggle\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n1. 表现和默认一致\r\n\r\n### 在组件外 无 Memo 依赖 useState，内部 useMemo\r\n\r\n```tsx\r\nconst Outer11: React.FC\u003c{time1: string}\u003e = ({ time1 }) =\u003e {\r\n  console.log(\"Outer11\");\r\n\r\n  const timeMemo = useMemo(() =\u003e {\r\n    console.log(\"Outer11 useMemo\");\r\n\r\n    return time1 + \"-----\";\r\n  }, [time1]);\r\n\r\n  return \u003cdiv\u003eOuter11 {timeMemo}\u003c/div\u003e;\r\n};\r\n```\r\n\r\n1. 表现默认一致\r\n2. useMemo 默认执行\r\n\r\n### 在组件外 使用 ahooks useEventEmitter 测试\r\n\r\n```tsx\r\n// Parent\r\nconst focus$ = useEventEmitter();\r\n\u003cbutton onClick={() =\u003e focus$.emit()}\u003eEvent\u003c/button\u003e\r\n```\r\n\r\n```tsx\r\nconst Outer12: React.FC\u003c{ focus$: EventEmitter\u003cvoid\u003e }\u003e = React.memo(\r\n  function Outer12({ focus$ }) {\r\n    console.log(\"Outer12\", focus$);\r\n\r\n    focus$.useSubscription(() =\u003e {\r\n      console.log(\"Outer12 emit\", focus$);\r\n    });\r\n    return \u003cdiv\u003eOuter12\u003c/div\u003e;\r\n  }\r\n);\r\n\r\nconst Outer13: React.FC\u003c{ focus$: EventEmitter\u003cvoid\u003e }\u003e = ({ focus$ }) =\u003e {\r\n  console.log(\"Outer13\", focus$);\r\n\r\n  focus$.useSubscription(() =\u003e {\r\n    console.log(\"Outer13 emit\", focus$);\r\n  });\r\n  return \u003cdiv\u003eOuter13\u003c/div\u003e;\r\n};\r\n```\r\n\r\n```\r\n// 默认\r\nApp Parent \r\nfocus$ \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter12 \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter13 \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\n\r\n// 改变 useState\r\nApp Parent \r\nfocus$ \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter13 \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\n\r\n// 发送事件 emit\r\nOuter12 emit \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\nOuter13 emit \r\nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\r\n\r\n```\r\n\r\n1. 默认执行机制\r\n2. useEventEmitter 事件不会触发渲染机制\r\n\r\n### PureComponent\r\n\r\n```tsx\r\ntype PureProps = {\r\n  time1: string;\r\n};\r\nclass Pure extends React.PureComponent\u003cPureProps\u003e {\r\n\r\n  componentDidMount() {\r\n    console.log('Pure')\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    console.log(\"PureCp---componentDidUpdate\");\r\n  }\r\n\r\n  render() {\r\n    return \u003ch3\u003ePureCp: {this.props.time1}\u003c/h3\u003e;\r\n  }\r\n}\r\n```\r\n\r\nhttps://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent\r\n\r\n\u003e`React.PureComponent` 与 [`React.Component`](https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent) 很相似。两者的区别在于 [`React.Component`](https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent) 并未实现 [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate)，而 `React.PureComponent` 中以浅层对比 prop 和 state 的方式来实现了该函数。\r\n\u003e\r\n\u003e如果赋予 React 组件相同的 props 和 state，`render()` 函数会渲染相同的内容，那么在某些情况下使用 `React.PureComponent` 可提高性能。","comments":{"nodes":[]},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"author":{"login":"xiaotiandada","url":"https://github.com/xiaotiandada","avatarUrl":"https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d\u0026v=4"},"html":"\u003ch2 id=\"reactmemo\"\u003e\u003ccode\u003eReact.memo\u003c/code\u003e\u003c/h2\u003e\n\u003cpre class=\"language-react\"\u003e\u003ccode class=\"language-react\"\u003econst MyComponent = React.memo(function MyComponent(props) {\n  /* 使用 props 渲染 */\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactmemo\"\u003ehttps://zh-hans.reactjs.org/docs/react-api.html#reactmemo\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 \u003ccode\u003eReact.memo\u003c/code\u003e 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReact.memo\u003c/code\u003e 仅检查 props 变更。如果函数组件被 \u003ccode\u003eReact.memo\u003c/code\u003e 包裹，且其实现中拥有 \u003ca href=\"https://zh-hans.reactjs.org/docs/hooks-state.html\"\u003e\u003ccode\u003euseState\u003c/code\u003e\u003c/a\u003e，\u003ca href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer\"\u003e\u003ccode\u003euseReducer\u003c/code\u003e\u003c/a\u003e 或 \u003ca href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext\"\u003e\u003ccode\u003euseContext\u003c/code\u003e\u003c/a\u003e 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。\u003c/p\u003e\n\u003cp\u003e...\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://codesandbox.io/s/react-memo-qknj7?file=/src/App.tsx\"\u003edemo\u003c/a\u003e 代码都在这儿\u003c/p\u003e\n\u003ch3 id=\"默认情况\"\u003e默认情况\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econsole.log(\"App Parent\");\n\nconst [time, setTime] = useState\u003cstring\u003e(\"\");\nconst [time1, setTime1] = useState\u003cstring\u003e(\"\");\n\n\u003cdiv\u003e\n  \u003cdiv\u003eParent\u003c/div\u003e\n  \u003cul\u003e\n    \u003cli\u003etime: {time}\u003c/li\u003e\n    \u003cli\u003etime1: {time1}\u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cbutton onClick={() =\u003e setTime(\"1111\")}\u003etoggle\u003c/button\u003e\n  \u003cbutton onClick={() =\u003e setTime1(String(Date.now()))}\u003etoggle1\u003c/button\u003e\n  \u003cbutton onClick={() =\u003e setTime1(\"0000000000\")}\u003etoggle1\u003c/button\u003e\n\u003c/div\u003e\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e默认执行 输出 \u003ccode\u003eApp Parent\u003c/code\u003e 一次\u003c/li\u003e\n\u003cli\u003e组件内 useState 变动则会重新渲染一次\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"默认组件-在组件内\"\u003e默认组件 在组件内\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003e  const child1: React.FC = () =\u003e {\n    console.log(\"child1\");\n    return (\n      \u003cdiv\u003e\n        \u003cdiv\u003echild1\u003c/div\u003e\n        \u003cbutton onClick={() =\u003e setTime1(\"child1\")}\u003etoggle\u003c/button\u003e\n        \u003cbutton onClick={() =\u003e setTime1(String(Date.now()))}\u003etoggle\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  };\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e父组件渲染一次 child1 也渲染一次\u003c/li\u003e\n\u003cli\u003e父组件 useState 改动 父组件和 child1 渲染一次\u003c/li\u003e\n\u003cli\u003echild1 组件 useState 改动 父组件和 child1 渲染一次\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"默认组件-使用方式\"\u003e默认组件 使用方式\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003e\u003cdiv\u003e{Child1()}\u003c/div\u003e\n\u003cChild2 /\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eApp Parent \nChild1 \nChild2 \n\nApp Parent \nChild1 \u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e表现基本与上面一致\u003c/li\u003e\n\u003cli\u003e第一次 都渲染，后面 修改相同 useState 执行 Child1，修改不相同 useState 执行  Child1 Child2\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"memo-在组件内\"\u003eMemo 在组件内\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Child3: React.FC = React.memo(function Child3() {\n  console.log(\"Child3\");\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eChild2\u003c/div\u003e\n      \u003cdiv\u003e{time}\u003c/div\u003e\n      \u003cdiv\u003e{time1}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n});\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e无效 表现和默认一致\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件内-无依赖-修改-usestate\"\u003e在组件内 无依赖 修改 useState\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003e  const Child4: React.FC = () =\u003e {\n    console.log(\"Child4\");\n    const [state, setstate] = useState(\"\");\n\n    return (\n      \u003cdiv\u003e\n        \u003cdiv\u003e{state}\u003c/div\u003e\n        \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003etoggle\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  };\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e只渲染当前组件\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-默认组件-无依赖\"\u003e在组件外 默认组件 无依赖\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer1 = () =\u003e {\n  console.log(\"Outer1\");\n  return \u003cdiv\u003eOuter1\u003c/div\u003e;\n};\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e表现和默认一致\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003eApp Parent \nOuter1 \u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"在组件外-momo-无依赖\"\u003e在组件外 Momo 无依赖\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer2 = React.memo(function Outer2() {\n  console.log(\"Outer2\");\n  return \u003cdiv\u003eOuter2\u003c/div\u003e;\n});\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\nApp Parent \nOuter1 \nOuter2 \nApp Parent \nOuter1\nApp Parent \nOuter1 \u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e只会渲染一次 父级 useState 改变不受影响\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-memo-usestate-依赖\"\u003e在组件外 Memo useState 依赖\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer3: React.FC\u003c{ time1: string }\u003e = React.memo(function Outer3({\n  time1\n}) {\n  console.log(\"Outer3 time1\", time1);\n  return \u003cdiv\u003eOuter3 {time1}\u003c/div\u003e;\n});\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\nApp Parent \nOuter1 \nOuter2 \nOuter3 time1 \"\" \nApp Parent \nOuter1 \nOuter3 time1 1630983888577 \nApp Parent \nOuter1 \nOuter3 time1 1630983892146 \u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e默认执行一次\u003c/li\u003e\n\u003cli\u003e依赖外 useState 变动不渲染\u003c/li\u003e\n\u003cli\u003e依赖 useState 变动渲染一次\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-memo-usestate-依赖-，-内部拥有-usestate\"\u003e在组件外 Memo useState 依赖 ， 内部拥有 useState\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer4: React.FC\u003c{ time1: string }\u003e = React.memo(function Outer4({\n  time1\n}) {\n  const [state, setstate] = useState(\"\");\n\n  console.log(\"Outer4\");\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eOuter4 state {state}\u003c/div\u003e\n      \u003cdiv\u003eOuter4 time1 {time1}\u003c/div\u003e\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003eToggle\u003c/button\u003e\n    \u003c/div\u003e\n  );\n});\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eApp Parent \nOuter1 \nOuter2 \nOuter3 time1 \"\" \nOuter4 \nApp Parent \nOuter1 \nApp Parent \nOuter1 \nOuter3 time1 1630984999782 \nOuter4 \nOuter4 \u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e同上\u003c/li\u003e\n\u003cli\u003e内部 useState 变动渲染一次\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-memo-function-依赖-在父级组件内定义\"\u003e在组件外 Memo function 依赖 (在父级组件内定义)\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer5: React.FC\u003c{ fn: () =\u003e void }\u003e = React.memo(function Outer5({\n  fn\n}) {\n  const [state, setstate] = useState(\"\");\n\n  console.log(\"Outer5\");\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eOuter5 state {state}\u003c/div\u003e\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003eToggle\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e fn()}\u003eFn\u003c/button\u003e\n    \u003c/div\u003e\n  );\n});\n\nconst Outer4Fn = () =\u003e {\n  console.log(\"Outer4Fn\");\n};\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\nApp Parent \nOuter1 \nOuter2 \nOuter3 time1 \"\" \nOuter4 \nOuter5 \n\nApp Parent \nOuter1 \nOuter5 \n\nApp Parent \nOuter1 \nOuter3 time1 1630985278410 \nOuter4 \nOuter5 \n\nApp Parent \nOuter1 \nOuter3 time1 1630985281298 \nOuter4 \nOuter5 \n\nOuter4Fn \nOuter4Fn \u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e默认渲染一次\u003c/li\u003e\n\u003cli\u003e修改父级组件 useState 渲染一次\u003c/li\u003e\n\u003cli\u003e执行 fn 不渲染\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e应该是父级渲染导致方法重新更新/定义返回了新的方法 导致渲染（这里是猜测 但是大概应该就是这样），解决这个问题需要用 useCallback 包裹方法即可, 在依赖没有变动的情况下返回相同的方法\u003c/p\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer4FnCallback = useCallback(() =\u003e {\n  console.log(\"Outer4FnCallback\");\n}, []);\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"在组件外-memo-变量依赖在父级组件内定义\"\u003e在组件外 Memo 变量依赖(在父级组件内定义)\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer6V = \"var\";\nconst Outer6V = [1,2,3]\n\n\nconst Outer6: React.FC\u003c{ v: string }\u003e = React.memo(function Outer6({ v }) {\n  console.log(\"Outer6\", v);\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eOuter6 {v}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n});\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e字符变量 和默认 Memo 无依赖表现一致\u003c/li\u003e\n\u003cli\u003e数组/对象 每次父组件更新会重新渲染，返回了新的引用\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果想定义对象变量又不想触发重新渲染用 useMemo包裹即可\u003c/p\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer6V = useMemo(() =\u003e {\n    return { a: 1 };\n}, []);\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"在组件外-memo-无依赖-调用外部-方法\"\u003e在组件外 Memo 无依赖 调用外部 方法\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer7Outer = () =\u003e {\n  console.log(\"c4Test\");\n};\n\nconst Outer7: React.FC = React.memo(function Outer7({}) {\n  const [state, setstate] = useState(\"\");\n\n  console.log(\"Outer7\");\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eOuter7 state {state}\u003c/div\u003e\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003eC4\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e Outer7Outer()}\u003eFn\u003c/button\u003e\n    \u003c/div\u003e\n  );\n});\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e父级渲染不影响组件\u003c/li\u003e\n\u003cli\u003e方法固定引用不重新渲染\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-memo-依赖传入外部方法\"\u003e在组件外 Memo 依赖传入外部方法\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer7Outer = () =\u003e {\n  console.log(\"Outer7Outer\");\n};\n\nconst Outer8: React.FC\u003c{ fn: () =\u003e void }\u003e = React.memo(function Outer8({\n  fn\n}) {\n  console.log(\"Outer8\");\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e fn()}\u003eFn\u003c/button\u003e\n    \u003c/div\u003e\n  );\n});\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e同上 没有影响\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-memo-依赖传入-object-数据\"\u003e在组件外 Memo 依赖传入 Object 数据\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer9: React.FC\u003c{ list: object }\u003e = React.memo(function Outer9({\n  list\n}) {\n  console.log(\"Outer9\");\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eOuter9 {JSON.stringify(list)}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n});\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e表现和默认 Memo 行为一样\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-无-memo-无依赖-内部-usestate-变动\"\u003e在组件外 无 Memo 无依赖 内部 useState 变动\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer10: React.FC = () =\u003e {\n  console.log(\"Outer10\");\n  const [state, setstate] = useState(\"\");\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eOuter10 {state}\u003c/div\u003e\n      \u003cbutton onClick={() =\u003e setstate(String(Date.now()))}\u003etoggle\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e表现和默认一致\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-无-memo-依赖-usestate，内部-usememo\"\u003e在组件外 无 Memo 依赖 useState，内部 useMemo\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer11: React.FC\u003c{time1: string}\u003e = ({ time1 }) =\u003e {\n  console.log(\"Outer11\");\n\n  const timeMemo = useMemo(() =\u003e {\n    console.log(\"Outer11 useMemo\");\n\n    return time1 + \"-----\";\n  }, [time1]);\n\n  return \u003cdiv\u003eOuter11 {timeMemo}\u003c/div\u003e;\n};\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e表现默认一致\u003c/li\u003e\n\u003cli\u003euseMemo 默认执行\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"在组件外-使用-ahooks-useeventemitter-测试\"\u003e在组件外 使用 ahooks useEventEmitter 测试\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003e// Parent\nconst focus$ = useEventEmitter();\n\u003cbutton onClick={() =\u003e focus$.emit()}\u003eEvent\u003c/button\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003econst Outer12: React.FC\u003c{ focus$: EventEmitter\u003cvoid\u003e }\u003e = React.memo(\n  function Outer12({ focus$ }) {\n    console.log(\"Outer12\", focus$);\n\n    focus$.useSubscription(() =\u003e {\n      console.log(\"Outer12 emit\", focus$);\n    });\n    return \u003cdiv\u003eOuter12\u003c/div\u003e;\n  }\n);\n\nconst Outer13: React.FC\u003c{ focus$: EventEmitter\u003cvoid\u003e }\u003e = ({ focus$ }) =\u003e {\n  console.log(\"Outer13\", focus$);\n\n  focus$.useSubscription(() =\u003e {\n    console.log(\"Outer13 emit\", focus$);\n  });\n  return \u003cdiv\u003eOuter13\u003c/div\u003e;\n};\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e// 默认\nApp Parent \nfocus$ \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter12 \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter13 \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\n\n// 改变 useState\nApp Parent \nfocus$ \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter13 \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\n\n// 发送事件 emit\nOuter12 emit \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\nOuter13 emit \nEventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e默认执行机制\u003c/li\u003e\n\u003cli\u003euseEventEmitter 事件不会触发渲染机制\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"purecomponent\"\u003ePureComponent\u003c/h3\u003e\n\u003cpre class=\"language-tsx\"\u003e\u003ccode class=\"language-tsx\"\u003etype PureProps = {\n  time1: string;\n};\nclass Pure extends React.PureComponent\u003cPureProps\u003e {\n\n  componentDidMount() {\n    console.log('Pure')\n  }\n\n  componentDidUpdate() {\n    console.log(\"PureCp---componentDidUpdate\");\n  }\n\n  render() {\n    return \u003ch3\u003ePureCp: {this.props.time1}\u003c/h3\u003e;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent\"\u003ehttps://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eReact.PureComponent\u003c/code\u003e 与 \u003ca href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent\"\u003e\u003ccode\u003eReact.Component\u003c/code\u003e\u003c/a\u003e 很相似。两者的区别在于 \u003ca href=\"https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent\"\u003e\u003ccode\u003eReact.Component\u003c/code\u003e\u003c/a\u003e 并未实现 \u003ca href=\"https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate\"\u003e\u003ccode\u003eshouldComponentUpdate()\u003c/code\u003e\u003c/a\u003e，而 \u003ccode\u003eReact.PureComponent\u003c/code\u003e 中以浅层对比 prop 和 state 的方式来实现了该函数。\u003c/p\u003e\n\u003cp\u003e如果赋予 React 组件相同的 props 和 state，\u003ccode\u003erender()\u003c/code\u003e 函数会渲染相同的内容，那么在某些情况下使用 \u003ccode\u003eReact.PureComponent\u003c/code\u003e 可提高性能。\u003c/p\u003e\n\u003c/blockquote\u003e\n","attributes":{}},"themeConfig":{"title":"Blog(issues)","links":[{"title":"GitHub","url":"https://github.com/xiaotiandada/blog"},{"title":"Twitter","url":"https://twitter.com/XiaoTianIsMe"}]}},"__N_SSG":true},"page":"/[...path]","query":{"path":["MDU6SXNzdWU5NzU4MjUzMjY="]},"buildId":"YPEk3V-eoVeml18YoUSCM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>