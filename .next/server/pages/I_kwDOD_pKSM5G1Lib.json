{"pageProps":{"post":{"id":"I_kwDOD_pKSM5G1Lib","url":"https://github.com/xiaotiandada/blog/issues/96","title":"React","updatedAt":"2022-06-07T08:07:39Z","createdAt":"2022-03-31T16:31:47Z","body":"介绍全新的 JSX 转换 v17.0 RC\r\n\r\nhttps://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html\r\nhttps://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\r\n\r\n旧的 JSX 转换将 JSX 转换为React.createElement(...)调用，\r\n新的 JSX 转换不是将 JSX 转换为React.createElement，而是自动从 React 包中的这些新入口点导入特殊函数并调用它们。\r\n\r\n```tsx\r\n// Inserted by a compiler (don't import it yourself!)\r\nimport {jsx as _jsx} from 'react/jsx-runtime';\r\n\r\nfunction App() {\r\n  return _jsx('h1', { children: 'Hello world' });\r\n}\r\n```\r\n\r\n```tsx\r\n<h1 id=\"title\" key=\"title\" style={{ width: 100 }} onClick={() => console.log('onClick')}>hello<span data=\"d\">12313</span></h1>\r\n```\r\n\r\n\r\n```js\r\n\"use strict\";\r\n\r\n/*#__PURE__*/\r\nReact.createElement(\"h1\", {\r\n  id: \"title\",\r\n  key: \"title\",\r\n  style: {\r\n    width: 100\r\n  },\r\n  onClick: () => console.log('onClick')\r\n}, \"hello\", /*#__PURE__*/React.createElement(\"span\", {\r\n  data: \"d\"\r\n}, \"12313\"));\r\n```\r\n\r\n- https://astexplorer.net/\r\n- https://babeljs.io\r\n\r\n```js\r\nexport const REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\r\n\r\nimport { REACT_ELEMENT_TYPE } from \"./shared/ReactSymbols\";\r\n\r\nconst RESERVED_PROPS = {\r\n  key: true,\r\n  ref: true,\r\n  __self: true,\r\n  __source: true,\r\n};\r\n\r\n/**\r\n * Factory method to create a new React element. This no longer adheres to\r\n * the class pattern, so do not use new to call it. Also, instanceof check\r\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n * if something is a React Element.\r\n *\r\n * @param {*} type\r\n * @param {*} props\r\n * @param {*} key\r\n * @param {string|object} ref\r\n * @param {*} owner\r\n * @param {*} self A *temporary* helper to detect places where `this` is\r\n * different from the `owner` when React.createElement is called, so that we\r\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n * functions, and as long as `this` and owner are the same, there will be no\r\n * change in behavior.\r\n * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n * indicating filename, line number, and/or other information.\r\n * @internal\r\n */\r\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\r\n  const element = {\r\n    // This tag allows us to uniquely identify this as a React Element\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n\r\n    // Built-in properties that belong on the element\r\n    type: type,\r\n    key: key,\r\n    ref: ref,\r\n    props: props,\r\n\r\n    // Record the component responsible for creating this element.\r\n    _owner: owner,\r\n    _store: {},\r\n    _self: self,\r\n    _source: source,\r\n  };\r\n\r\n  return element;\r\n};\r\n\r\nexport function createElement(type, config, children) {\r\n  // Reserved names are extracted\r\n  const props = {};\r\n\r\n  let key = null;\r\n  let ref = null;\r\n  let self = null;\r\n  let source = null;\r\n\r\n  if (config != null) {\r\n    key = \"\" + config.key;\r\n\r\n    self = config.__self === undefined ? null : config.__self;\r\n    source = config.__source === undefined ? null : config.__source;\r\n    // Remaining properties are added to a new props object\r\n    for (const proName in config) {\r\n      if (\r\n        Object.hasOwnProperty.call(config, proName) &&\r\n        !RESERVED_PROPS.hasOwnProperty(proName)\r\n      ) {\r\n        props[proName] = config[proName];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Children can be more than one argument, and those are transferred onto\r\n  // the newly allocated props object.\r\n  const childrenLength = arguments.length - 2;\r\n  if (childrenLength === 1) {\r\n    props.children = children;\r\n  } else if (childrenLength > 1) {\r\n    const childArray = Array(childrenLength);\r\n    for (let i = 0; i < childArray.length; i++) {\r\n      childArray[i] = arguments[i + 2];\r\n    }\r\n\r\n    props.children = childArray;\r\n  }\r\n\r\n  const _owner = null;\r\n  return ReactElement(type, key, ref, self, source, _owner, props);\r\n}\r\n\r\n```\r\n\r\n```js\r\nconst emptyObject = {};\r\n\r\n/**\r\n * Base class helpers for the updating state of a component.\r\n */\r\nexport function Component(props) {\r\n  this.props = props;\r\n  this.refs = emptyObject;\r\n}\r\n\r\nComponent.prototype.isReactComponent = {};\r\n```\r\n\r\n```jsx\r\nclass PureComponents extends React.Component {\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    console.log(\"nextProps\", nextProps, nextState);\r\n    return (\r\n      shallowEqual(nextProps, this.props) && shallowEqual(nextState, this.state)\r\n    );\r\n  }\r\n}\r\n\r\nfunction shallowEqual(object1, object2) {\r\n  if (object1 === object2) {\r\n    return true;\r\n  }\r\n\r\n  if (\r\n    typeof object1 !== \"object\" ||\r\n    object1 === null ||\r\n    object2 !== \"object\" ||\r\n    object2 === null\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  const keys1 = Object.keys(object1);\r\n  const keys2 = Object.keys(object2);\r\n\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < keys1.length; i++) {\r\n    if (\r\n      !hasOwnProperty.call(object2, keys1[i]) ||\r\n      object1[keys1[i]] !== object2[keys1[i]]\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n```\r\n\r\n### React16废弃了哪些生命周期？为什么？\r\n\r\n- https://blog.csdn.net/weixin_43392489/article/details/121438376\r\n\r\nReact16废弃的生命周期有3个will：\r\ncomponentWillMount\r\ncomponentWillReceiveProps\r\ncomponentWillUpdate\r\n\r\n## v16.13.1\r\n\r\n### createElement\r\n```tsx\r\nimport { REACT_ELEMENT_TYPE } from '../../shared/ReactSymbols';\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nconst RESERVED_PROPS = {\r\n  key: true,\r\n  ref: true,\r\n  __self: true,\r\n  __source: true,\r\n};\r\n\r\n/**\r\n * Create and return a new ReactElement of the given type.\r\n * See https://reactjs.org/docs/react-api.html#createelement\r\n */\r\nexport function createElement(type: any, config: any, children: any) {\r\n  /**\r\n   * propName -> 属性名称\r\n   * 用于后面的 for 循环\r\n   */\r\n  let propName: any;\r\n\r\n  /**\r\n   * 存储 React Element 中的普通元素属性 即不包含 key ref self source\r\n   */\r\n  // Reserved names are extracted\r\n  const props: { [key: string]: any } = {};\r\n\r\n  /**\r\n   * 待提取属性\r\n   * React 内部为了实现某些功能而存在的属性\r\n   */\r\n  let key = null;\r\n  let ref = null;\r\n  let self = null;\r\n  let source = null;\r\n\r\n  // 如果 config 不为 null\r\n  if (config !== null) {\r\n    // 如果 config 对象中有合法的 ref 属性\r\n    if (hasValidRef(config)) {\r\n      // 将 config.ref 属性提取到 ref 变量中\r\n      ref = config.ref;\r\n    }\r\n    // 如果在 config 对象中拥有合法的 key 属性\r\n    if (hasValidKey(config)) {\r\n      // 将 config.key 属性中的值提取到 key 变量中\r\n      key = '' + config.key;\r\n    }\r\n\r\n    self = config.__self === undefined ? null : config.__self;\r\n    source = config.__source === undefined ? null : config.__source;\r\n\r\n    // 遍历 config 对象\r\n    // Remaining properties are added to a new props object\r\n    for (propName in config) {\r\n      // 如果当前遍历到的属性是对象自身属性\r\n      // 并且在 RESERVED_PROPS 对象中不存在该属性\r\n      if (\r\n        hasOwnProperty.call(config, propName) &&\r\n        !RESERVED_PROPS.hasOwnProperty(propName)\r\n      ) {\r\n        // 将满足条件的属性添加到 props 对象中 (普通属性)\r\n        props[propName] = config[propName];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 将第三个及之后的参数挂载到 props.children 属性中\r\n   * 如果子元素是多个 props.children 是数组\r\n   * 如果子元素是一个 props.children 是对象\r\n   */\r\n\r\n  // 由于从第三个参数开始及以后都表示子元素\r\n  // 所以减去前两个参数的结果就是子元素的数量\r\n\r\n  // Children can be more than one argument, and those are transferred onto\r\n  // the newly allocated props object.\r\n  const childrenLength = arguments.length - 2;\r\n  // 如果子元素的数量是 1\r\n  if (childrenLength === 1) {\r\n    // 直接将子元素挂载到到 props.children 属性上\r\n    // 此时 children 是对象类型\r\n    props.children = children;\r\n    // 如果子元素的数量大于 1\r\n  } else if (childrenLength > 1) {\r\n    // 创建数组, 数组中元素的数量等于子元素的数量\r\n    const childArray = Array(childrenLength);\r\n    // 开启循环 循环次匹配子元素的数量\r\n    for (let i = 0; i < childrenLength; i++) {\r\n      // 将子元素添加到 childArray 数组中\r\n      // i + 2 的原因是实参集合的前两个参数不是子元素\r\n      childArray[i] = arguments[i + 2];\r\n    }\r\n\r\n    // 将子元素数组挂载到 props.children 属性中\r\n    props.children = childArray;\r\n  }\r\n\r\n  /**\r\n   * 如果当前处理是组件\r\n   * 看组件身上是否有 defaultProps 属性\r\n   * 这个属性中存储的是 props 对象中属性的默认值\r\n   * 遍历 defaultProps 对象 查看对应的 props 属性的值是否为 undefined\r\n   * 如果为undefined 就将默认值赋值给对应的 props 属性值\r\n   */\r\n\r\n  // Resolve default props\r\n  if (type && type.defaultProps) {\r\n    const defaultProps = type.defaultProps;\r\n    for (propName in defaultProps) {\r\n      if (props[propName] === undefined) {\r\n        props[propName] = defaultProps[propName];\r\n      }\r\n    }\r\n  }\r\n\r\n  return ReactElement(\r\n    type,\r\n    key,\r\n    ref,\r\n    self,\r\n    source,\r\n    null, // ReactCurrentOwner.current,\r\n    props\r\n  );\r\n}\r\n```\r\n\r\n### ReactElement\r\n\r\n```tsx\r\n// 接收参数 返回 ReactElement\r\n/**\r\n * Factory method to create a new React element. This no longer adheres to\r\n * the class pattern, so do not use new to call it. Also, instanceof check\r\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n * if something is a React Element.\r\n *\r\n * @param {*} type\r\n * @param {*} props\r\n * @param {*} key\r\n * @param {string|object} ref\r\n * @param {*} owner\r\n * @param {*} self A *temporary* helper to detect places where `this` is\r\n * different from the `owner` when React.createElement is called, so that we\r\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n * functions, and as long as `this` and owner are the same, there will be no\r\n * change in behavior.\r\n * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n * indicating filename, line number, and/or other information.\r\n * @internal\r\n */\r\nconst ReactElement = function (\r\n  type: any,\r\n  key: any,\r\n  ref: any,\r\n  self: any,\r\n  source: any,\r\n  owner: any,\r\n  props: any\r\n) {\r\n  const element = {\r\n    /**\r\n     * 组件的类型, 十六进制数值或者 Symbol 值\r\n     * React 在最终在渲染 DOM 的时候, 需要确保元素的类型是 REACT_ELEMENT_TYPE\r\n     * 需要此属性作为判断的依据\r\n     */\r\n    // This tag allows us to uniquely identify this as a React Element\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n\r\n    /**\r\n     * 元素具体的类型值 如果是元素节点 type 属性中存储的就是 div span 等等\r\n     * 如果元素是组件 type 属性中存储的就是组件的构造函数\r\n     */\r\n    // Built-in properties that belong on the element\r\n    type: type,\r\n    /**\r\n     * 元素的唯一标识\r\n     * 用作内部 vdom 比对 提升 DOM 操作性能\r\n     */\r\n    key: key,\r\n    /**\r\n     * 存储元素 DOM 对象或者组件 实例对象\r\n     */\r\n    ref: ref,\r\n    /**\r\n     * 存储向组件内部传递的数据\r\n     */\r\n    props: props,\r\n\r\n    /**\r\n     * 记录当前元素所属组件 (记录当前元素是哪个组件创建的)\r\n     */\r\n    // Record the component responsible for creating this element.\r\n    _owner: owner,\r\n  };\r\n\r\n  // 返回 ReactElement\r\n  return element;\r\n};\r\n```\r\n\r\n### hasValidRef\r\n\r\n```tsx\r\n/**\r\n * 查看参数对象中是否有合法的 ref 属性\r\n * 返回布尔值\r\n */\r\nfunction hasValidRef(config: any) {\r\n  return config.ref !== undefined;\r\n}\r\n```\r\n\r\n### hasValidKey\r\n\r\n```tsx\r\n/**\r\n * 查看参数对象中是否有合法的 key 属性\r\n * 返回布尔值\r\n */\r\nfunction hasValidKey(config: any) {\r\n  return config.key !== undefined;\r\n}\r\n```\r\n\r\n### isValidElement\r\n\r\n```tsx\r\n/**\r\n * 验证 object 参数是否是 ReactElement. 返回布尔值\r\n * 验证成功的条件:\r\n * object 是对象\r\n * object 不为null\r\n * object对象中的 $$typeof 属性值为 REACT_ELEMENT_TYPE\r\n *\r\n * Verifies the object is a ReactElement.\r\n * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n * @param {?object} object\r\n * @return {boolean} True if `object` is a ReactElement.\r\n * @final\r\n */\r\nexport function isValidElement(object: { [key: string]: any }) {\r\n  return (\r\n    typeof object === 'object' &&\r\n    object !== null &&\r\n    object.$$typeof === REACT_ELEMENT_TYPE\r\n  );\r\n}\r\n```\r\n\r\n### defineKeyPropWarningGetter\r\n\r\n### defineRefPropWarningGetter\r\n\r\n```tsx\r\nlet specialPropKeyWarningShown: boolean;\r\nlet specialPropRefWarningShown: boolean;\r\n\r\n/**\r\n *  指定当通过 props 对象获取 key 属性时报错\r\n *  props        组件中的 props 对象\r\n *  displayName  组件名称标识\r\n */\r\nfunction defineKeyPropWarningGetter(\r\n  props: { [key: string]: any },\r\n  displayName: string\r\n) {\r\n  // 通过 props 对象获取 key 属性报错\r\n  const warnAboutAccessingKey = function () {\r\n    // 在开发环境中\r\n    if (__DEV__) {\r\n      // specialPropKeyWarningShown 控制错误只输出一次的变量\r\n      if (!specialPropKeyWarningShown) {\r\n        // 通过 specialPropKeyWarningShown 变量锁住判断条件\r\n        specialPropKeyWarningShown = true;\r\n        // 指定报错信息和组件名称\r\n        console.error(\r\n          '%s: `key` is not a prop. Trying to access it will result ' +\r\n            'in `undefined` being returned. If you need to access the same ' +\r\n            'value within the child component, you should pass it as a different ' +\r\n            'prop. (https://fb.me/react-special-props)',\r\n          displayName\r\n        );\r\n      }\r\n    }\r\n  };\r\n  warnAboutAccessingKey.isReactWarning = true;\r\n  // 为 props 对象添加 key 属性\r\n  Object.defineProperty(props, 'key', {\r\n    // 当获取 key 属性时调用 warnAboutAccessingKey 方法进行报错\r\n    get: warnAboutAccessingKey,\r\n    configurable: true,\r\n  });\r\n}\r\n\r\n/**\r\n *  指定当通过 props 对象获取 ref 属性时报错\r\n *  props        组件中的 props 对象\r\n *  displayName  组件名称标识\r\n */\r\nfunction defineRefPropWarningGetter(\r\n  props: { [key: string]: any },\r\n  displayName: string\r\n) {\r\n  // 通过 props 对象获取 ref 属性报错\r\n  const warnAboutAccessingRef = function () {\r\n    if (__DEV__) {\r\n      // specialPropRefWarningShown 控制错误只输出一次的变量\r\n      if (!specialPropRefWarningShown) {\r\n        // 通过 specialPropRefWarningShown 变量锁住判断条件\r\n        specialPropRefWarningShown = true;\r\n        // 指定报错信息和组件名称\r\n        console.error(\r\n          '%s: `ref` is not a prop. Trying to access it will result ' +\r\n            'in `undefined` being returned. If you need to access the same ' +\r\n            'value within the child component, you should pass it as a different ' +\r\n            'prop. (https://fb.me/react-special-props)',\r\n          displayName\r\n        );\r\n      }\r\n    }\r\n  };\r\n  warnAboutAccessingRef.isReactWarning = true;\r\n  // 为 props 对象添加 key 属性\r\n  Object.defineProperty(props, 'ref', {\r\n    get: warnAboutAccessingRef,\r\n    configurable: true,\r\n  });\r\n}\r\n\r\nconst props = { ref: 'ref', key: 'key' };\r\ndefineKeyPropWarningGetter(props, 'key');\r\ndefineRefPropWarningGetter(props, 'ref');\r\n\r\nprops.key;\r\nprops.ref;\r\n\r\n// key: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop.\r\n\r\n// ref: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. \r\n```\r\n\r\n### Render\r\n\r\n```tsx\r\n/**\r\n * 渲染入口\r\n * element 要进行渲染的 ReactElement, createElement 方法的返回值\r\n * container 渲染容器 <div id=\"root\"></div>\r\n * callback 渲染完成后执行的回调函数\r\n */\r\nexport function render(\r\n  element: any,\r\n  container: Container,\r\n  callback?: Function\r\n) {\r\n  console.log('render', element, container, callback);\r\n\r\n  // 检测 container 是否是符合要求的渲染容器\r\n  // 即检测 container 是否是真实的DOM对象\r\n  // 如果不符合要求就报错\r\n  invariant(\r\n    isValidContainer(container),\r\n    'Target container is not a DOM element.'\r\n  );\r\n\r\n  return legacyRenderSubtreeIntoContainer(\r\n    // 父组件 初始渲染没有父组件 传递 null 占位\r\n    null,\r\n    element,\r\n    container,\r\n    // 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染\r\n    false,\r\n    callback\r\n  );\r\n}\r\n```\r\n\r\n### isValidContainer\r\n\r\n```tsx\r\n/**\r\n * 判断 node 是否是符合要求的 DOM 节点\r\n * 1. node 可以是元素节点\r\n * 2. node 可以是 document 节点\r\n * 3. node 可以是 文档碎片节点\r\n * 4. node 可以是注释节点但注释内容必须是 react-mount-point-unstable\r\n * \t\treact 内部会找到注释节点的父级 通过调用父级元素的 insertBefore 方法, 将 element 插入到注释节点的前面\r\n *\r\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType\r\n */\r\nexport function isValidContainer(node: any): boolean {\r\n  return !!(\r\n    node &&\r\n    (node.nodeType === ELEMENT_NODE ||\r\n      node.nodeType === DOCUMENT_NODE ||\r\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\r\n      (node.nodeType === COMMENT_NODE &&\r\n        (node as any).nodeValue === ' react-mount-point-unstable '))\r\n  );\r\n}\r\n```\r\n\r\n### react-mount-point-unstable\r\n\r\n- https://github.com/facebook/react/issues/17547\r\n\r\n- https://codesandbox.io/s/react-comment-node-as-root-element-2bqz8?file=/src/index.js:179-197\r\n\r\n\r\n\r\n<img width=\"1280\" alt=\"image\" src=\"https://user-images.githubusercontent.com/24250627/172046543-d4279aff-7979-4552-b731-f31297fdbd9b.png\">\r\n\r\n","comments":{"nodes":[]},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"author":{"login":"xiaotiandada","url":"https://github.com/xiaotiandada","avatarUrl":"https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d&v=4"},"html":"<p>介绍全新的 JSX 转换 v17.0 RC</p>\n<p><a href=\"https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html\">https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html</a>\n<a href=\"https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\">https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html</a></p>\n<p>旧的 JSX 转换将 JSX 转换为React.createElement(...)调用，\n新的 JSX 转换不是将 JSX 转换为React.createElement，而是自动从 React 包中的这些新入口点导入特殊函数并调用它们。</p>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">// Inserted by a compiler (don't import it yourself!)\nimport {jsx as _jsx} from 'react/jsx-runtime';\n\nfunction App() {\n  return _jsx('h1', { children: 'Hello world' });\n}</code></pre><pre class=\"language-tsx\"><code class=\"language-tsx\"><h1 id=\"title\" key=\"title\" style={{ width: 100 }} onClick={() => console.log('onClick')}>hello<span data=\"d\">12313</span></h1></code></pre><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*#__PURE__*/</span>\nReact<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"h1\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token string\">\"title\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">key</span><span class=\"token operator\">:</span> <span class=\"token string\">\"title\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">style</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">width</span><span class=\"token operator\">:</span> <span class=\"token number\">100</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">onClick</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'onClick'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/*#__PURE__*/</span>React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"span\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> <span class=\"token string\">\"d\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"12313\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre><ul>\n<li><a href=\"https://astexplorer.net/\">https://astexplorer.net/</a></li>\n<li><a href=\"https://babeljs.io\">https://babeljs.io</a></li>\n</ul>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token constant\">REACT_ELEMENT_TYPE</span> <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"react.element\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token constant\">REACT_ELEMENT_TYPE</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./shared/ReactSymbols\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">RESERVED_PROPS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">key</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">ref</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">__self</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">__source</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ReactElement</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> owner<span class=\"token punctuation\">,</span> props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This tag allows us to uniquely identify this as a React Element</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token constant\">REACT_ELEMENT_TYPE</span><span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\">// Built-in properties that belong on the element</span>\n    <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> type<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">key</span><span class=\"token operator\">:</span> key<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">ref</span><span class=\"token operator\">:</span> ref<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> props<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\">// Record the component responsible for creating this element.</span>\n    <span class=\"token literal-property property\">_owner</span><span class=\"token operator\">:</span> owner<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">_store</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">_self</span><span class=\"token operator\">:</span> self<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">_source</span><span class=\"token operator\">:</span> source<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> element<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">,</span> children</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Reserved names are extracted</span>\n  <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> key <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> ref <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> source <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>config <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    key <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span> <span class=\"token operator\">+</span> config<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n\n    self <span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>__self <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> config<span class=\"token punctuation\">.</span>__self<span class=\"token punctuation\">;</span>\n    source <span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>__source <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> config<span class=\"token punctuation\">.</span>__source<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Remaining properties are added to a new props object</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> proName <span class=\"token keyword\">in</span> config<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n        Object<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">,</span> proName<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token operator\">!</span><span class=\"token constant\">RESERVED_PROPS</span><span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>proName<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        props<span class=\"token punctuation\">[</span>proName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> config<span class=\"token punctuation\">[</span>proName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Children can be more than one argument, and those are transferred onto</span>\n  <span class=\"token comment\">// the newly allocated props object.</span>\n  <span class=\"token keyword\">const</span> childrenLength <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childrenLength <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    props<span class=\"token punctuation\">.</span>children <span class=\"token operator\">=</span> children<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childrenLength <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> childArray <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span>childrenLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> childArray<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      childArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    props<span class=\"token punctuation\">.</span>children <span class=\"token operator\">=</span> childArray<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> _owner <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">ReactElement</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> _owner<span class=\"token punctuation\">,</span> props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> emptyObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Base class helpers for the updating state of a component.\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>refs <span class=\"token operator\">=</span> emptyObject<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre><pre class=\"language-jsx\"><code class=\"language-jsx\">class PureComponents extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(\"nextProps\", nextProps, nextState);\n    return (\n      shallowEqual(nextProps, this.props) && shallowEqual(nextState, this.state)\n    );\n  }\n}\n\nfunction shallowEqual(object1, object2) {\n  if (object1 === object2) {\n    return true;\n  }\n\n  if (\n    typeof object1 !== \"object\" ||\n    object1 === null ||\n    object2 !== \"object\" ||\n    object2 === null\n  ) {\n    return false;\n  }\n\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < keys1.length; i++) {\n    if (\n      !hasOwnProperty.call(object2, keys1[i]) ||\n      object1[keys1[i]] !== object2[keys1[i]]\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}</code></pre><h3 id=\"react16废弃了哪些生命周期？为什么？\">React16废弃了哪些生命周期？为什么？</h3>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_43392489/article/details/121438376\">https://blog.csdn.net/weixin_43392489/article/details/121438376</a></li>\n</ul>\n<p>React16废弃的生命周期有3个will：\ncomponentWillMount\ncomponentWillReceiveProps\ncomponentWillUpdate</p>\n<h2 id=\"v16131\">v16.13.1</h2>\n<h3 id=\"createelement\">createElement</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">import { REACT_ELEMENT_TYPE } from '../../shared/ReactSymbols';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true,\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type: any, config: any, children: any) {\n  /**\n   * propName -> 属性名称\n   * 用于后面的 for 循环\n   */\n  let propName: any;\n\n  /**\n   * 存储 React Element 中的普通元素属性 即不包含 key ref self source\n   */\n  // Reserved names are extracted\n  const props: { [key: string]: any } = {};\n\n  /**\n   * 待提取属性\n   * React 内部为了实现某些功能而存在的属性\n   */\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  // 如果 config 不为 null\n  if (config !== null) {\n    // 如果 config 对象中有合法的 ref 属性\n    if (hasValidRef(config)) {\n      // 将 config.ref 属性提取到 ref 变量中\n      ref = config.ref;\n    }\n    // 如果在 config 对象中拥有合法的 key 属性\n    if (hasValidKey(config)) {\n      // 将 config.key 属性中的值提取到 key 变量中\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n\n    // 遍历 config 对象\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      // 如果当前遍历到的属性是对象自身属性\n      // 并且在 RESERVED_PROPS 对象中不存在该属性\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        // 将满足条件的属性添加到 props 对象中 (普通属性)\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  /**\n   * 将第三个及之后的参数挂载到 props.children 属性中\n   * 如果子元素是多个 props.children 是数组\n   * 如果子元素是一个 props.children 是对象\n   */\n\n  // 由于从第三个参数开始及以后都表示子元素\n  // 所以减去前两个参数的结果就是子元素的数量\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  // 如果子元素的数量是 1\n  if (childrenLength === 1) {\n    // 直接将子元素挂载到到 props.children 属性上\n    // 此时 children 是对象类型\n    props.children = children;\n    // 如果子元素的数量大于 1\n  } else if (childrenLength > 1) {\n    // 创建数组, 数组中元素的数量等于子元素的数量\n    const childArray = Array(childrenLength);\n    // 开启循环 循环次匹配子元素的数量\n    for (let i = 0; i < childrenLength; i++) {\n      // 将子元素添加到 childArray 数组中\n      // i + 2 的原因是实参集合的前两个参数不是子元素\n      childArray[i] = arguments[i + 2];\n    }\n\n    // 将子元素数组挂载到 props.children 属性中\n    props.children = childArray;\n  }\n\n  /**\n   * 如果当前处理是组件\n   * 看组件身上是否有 defaultProps 属性\n   * 这个属性中存储的是 props 对象中属性的默认值\n   * 遍历 defaultProps 对象 查看对应的 props 属性的值是否为 undefined\n   * 如果为undefined 就将默认值赋值给对应的 props 属性值\n   */\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    null, // ReactCurrentOwner.current,\n    props\n  );\n}</code></pre><h3 id=\"reactelement\">ReactElement</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">// 接收参数 返回 ReactElement\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nconst ReactElement = function (\n  type: any,\n  key: any,\n  ref: any,\n  self: any,\n  source: any,\n  owner: any,\n  props: any\n) {\n  const element = {\n    /**\n     * 组件的类型, 十六进制数值或者 Symbol 值\n     * React 在最终在渲染 DOM 的时候, 需要确保元素的类型是 REACT_ELEMENT_TYPE\n     * 需要此属性作为判断的依据\n     */\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    /**\n     * 元素具体的类型值 如果是元素节点 type 属性中存储的就是 div span 等等\n     * 如果元素是组件 type 属性中存储的就是组件的构造函数\n     */\n    // Built-in properties that belong on the element\n    type: type,\n    /**\n     * 元素的唯一标识\n     * 用作内部 vdom 比对 提升 DOM 操作性能\n     */\n    key: key,\n    /**\n     * 存储元素 DOM 对象或者组件 实例对象\n     */\n    ref: ref,\n    /**\n     * 存储向组件内部传递的数据\n     */\n    props: props,\n\n    /**\n     * 记录当前元素所属组件 (记录当前元素是哪个组件创建的)\n     */\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  // 返回 ReactElement\n  return element;\n};</code></pre><h3 id=\"hasvalidref\">hasValidRef</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">/**\n * 查看参数对象中是否有合法的 ref 属性\n * 返回布尔值\n */\nfunction hasValidRef(config: any) {\n  return config.ref !== undefined;\n}</code></pre><h3 id=\"hasvalidkey\">hasValidKey</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">/**\n * 查看参数对象中是否有合法的 key 属性\n * 返回布尔值\n */\nfunction hasValidKey(config: any) {\n  return config.key !== undefined;\n}</code></pre><h3 id=\"isvalidelement\">isValidElement</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">/**\n * 验证 object 参数是否是 ReactElement. 返回布尔值\n * 验证成功的条件:\n * object 是对象\n * object 不为null\n * object对象中的 $$typeof 属性值为 REACT_ELEMENT_TYPE\n *\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object: { [key: string]: any }) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}</code></pre><h3 id=\"definekeypropwarninggetter\">defineKeyPropWarningGetter</h3>\n<h3 id=\"definerefpropwarninggetter\">defineRefPropWarningGetter</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">let specialPropKeyWarningShown: boolean;\nlet specialPropRefWarningShown: boolean;\n\n/**\n *  指定当通过 props 对象获取 key 属性时报错\n *  props        组件中的 props 对象\n *  displayName  组件名称标识\n */\nfunction defineKeyPropWarningGetter(\n  props: { [key: string]: any },\n  displayName: string\n) {\n  // 通过 props 对象获取 key 属性报错\n  const warnAboutAccessingKey = function () {\n    // 在开发环境中\n    if (__DEV__) {\n      // specialPropKeyWarningShown 控制错误只输出一次的变量\n      if (!specialPropKeyWarningShown) {\n        // 通过 specialPropKeyWarningShown 变量锁住判断条件\n        specialPropKeyWarningShown = true;\n        // 指定报错信息和组件名称\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://fb.me/react-special-props)',\n          displayName\n        );\n      }\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  // 为 props 对象添加 key 属性\n  Object.defineProperty(props, 'key', {\n    // 当获取 key 属性时调用 warnAboutAccessingKey 方法进行报错\n    get: warnAboutAccessingKey,\n    configurable: true,\n  });\n}\n\n/**\n *  指定当通过 props 对象获取 ref 属性时报错\n *  props        组件中的 props 对象\n *  displayName  组件名称标识\n */\nfunction defineRefPropWarningGetter(\n  props: { [key: string]: any },\n  displayName: string\n) {\n  // 通过 props 对象获取 ref 属性报错\n  const warnAboutAccessingRef = function () {\n    if (__DEV__) {\n      // specialPropRefWarningShown 控制错误只输出一次的变量\n      if (!specialPropRefWarningShown) {\n        // 通过 specialPropRefWarningShown 变量锁住判断条件\n        specialPropRefWarningShown = true;\n        // 指定报错信息和组件名称\n        console.error(\n          '%s: `ref` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://fb.me/react-special-props)',\n          displayName\n        );\n      }\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  // 为 props 对象添加 key 属性\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true,\n  });\n}\n\nconst props = { ref: 'ref', key: 'key' };\ndefineKeyPropWarningGetter(props, 'key');\ndefineRefPropWarningGetter(props, 'ref');\n\nprops.key;\nprops.ref;\n\n// key: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop.\n\n// ref: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. </code></pre><h3 id=\"render\">Render</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">/**\n * 渲染入口\n * element 要进行渲染的 ReactElement, createElement 方法的返回值\n * container 渲染容器 <div id=\"root\"></div>\n * callback 渲染完成后执行的回调函数\n */\nexport function render(\n  element: any,\n  container: Container,\n  callback?: Function\n) {\n  console.log('render', element, container, callback);\n\n  // 检测 container 是否是符合要求的渲染容器\n  // 即检测 container 是否是真实的DOM对象\n  // 如果不符合要求就报错\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.'\n  );\n\n  return legacyRenderSubtreeIntoContainer(\n    // 父组件 初始渲染没有父组件 传递 null 占位\n    null,\n    element,\n    container,\n    // 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染\n    false,\n    callback\n  );\n}</code></pre><h3 id=\"isvalidcontainer\">isValidContainer</h3>\n<pre class=\"language-tsx\"><code class=\"language-tsx\">/**\n * 判断 node 是否是符合要求的 DOM 节点\n * 1. node 可以是元素节点\n * 2. node 可以是 document 节点\n * 3. node 可以是 文档碎片节点\n * 4. node 可以是注释节点但注释内容必须是 react-mount-point-unstable\n * \t\treact 内部会找到注释节点的父级 通过调用父级元素的 insertBefore 方法, 将 element 插入到注释节点的前面\n *\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType\n */\nexport function isValidContainer(node: any): boolean {\n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (node.nodeType === COMMENT_NODE &&\n        (node as any).nodeValue === ' react-mount-point-unstable '))\n  );\n}</code></pre><h3 id=\"react-mount-point-unstable\">react-mount-point-unstable</h3>\n<ul>\n<li><p><a href=\"https://github.com/facebook/react/issues/17547\">https://github.com/facebook/react/issues/17547</a></p>\n</li>\n<li><p><a href=\"https://codesandbox.io/s/react-comment-node-as-root-element-2bqz8?file=/src/index.js:179-197\">https://codesandbox.io/s/react-comment-node-as-root-element-2bqz8?file=/src/index.js:179-197</a></p>\n</li>\n</ul>\n<img width=\"1280\" alt=\"image\" src=\"https://user-images.githubusercontent.com/24250627/172046543-d4279aff-7979-4552-b731-f31297fdbd9b.png\">\n\n","attributes":{}},"themeConfig":{"title":"Blog(issues)","links":[{"title":"GitHub","url":"https://github.com/xiaotiandada/blog"},{"title":"Twitter","url":"https://twitter.com/XiaoTianIsMe"}]}},"__N_SSG":true}