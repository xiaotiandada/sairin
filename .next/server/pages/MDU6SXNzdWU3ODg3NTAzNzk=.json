{"pageProps":{"post":{"id":"MDU6SXNzdWU3ODg3NTAzNzk=","url":"https://github.com/xiaotiandada/blog/issues/52","title":"Nginx 负载均衡","updatedAt":"2021-01-19T06:37:26Z","createdAt":"2021-01-19T06:37:26Z","body":"2020-07-10 14:39:18\r\n\r\n## 一、负载均衡 - 初探\r\n\r\n**资料参考:** \r\n\r\nhttps://zhuanlan.zhihu.com/p/89356016\r\n\r\nhttps://juejin.im/post/5e60edbf5188254940670f75\r\n\r\n<!-- more -->\r\n\r\n服务器这边使用了 **Nodejs** 分别启两个服务 **7001** **7002**  和 两台机器 启动 **7001**\r\n\r\n**Nginx** 这边使用 **upstream** \r\n\r\nnginx的upstream目前支持的5种方式的分配\r\n\r\n1、轮询（默认） **本地测试了这种**\r\n\r\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\r\n\r\n```nginx\r\nupstream node { \r\n  server 127.0.0.1:7001; \r\n  server 127.0.0.1:7002; \r\n} \r\n```\r\n\r\n2 - 4 没有测试过 复制的....\r\n\r\n2、指定权重\r\n\r\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\r\n\r\n```nginx\r\nupstream backserver { \r\n  server 127.0.0.1:7001 weight=8; \r\n  server 127.0.0.1:7002 weight=10; \r\n} \r\n```\r\n\r\n3、IP绑定 ip_hash\r\n\r\n每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\r\n\r\n```nginx\r\nupstream backserver { \r\n  ip_hash; \r\n  server 127.0.0.1:7001; \r\n  server 127.0.0.1:7002; \r\n} \r\n```\r\n\r\n4、fair（第三方）\r\n\r\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\r\n\r\n```nginx\r\nupstream backserver { \r\n  server 127.0.0.1:7001; \r\n  server 127.0.0.1:7002; \r\n  fair; \r\n} \r\n```\r\n\r\n5、url_hash（第三方）\r\n\r\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\r\n\r\n```nginx\r\nupstream backserver { \r\n  server 127.0.0.1:7001; \r\n  server 127.0.0.1:7002; \r\n  hash $request_uri; \r\n  hash_method crc32; \r\n} \r\n```\r\n\r\n> max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误\r\n>\r\n> fail_timeout:max_fails次失败后，暂停的时间 (复制的...\r\n\r\n在 **Nginx** 定义 测试机\r\n\r\n```nginx\r\nhttp {\r\n\tupstream node {\r\n    server 127.0.0.1:7001;\r\n    server 192.168.1.11:7002;\r\n  }\r\n  \r\n  # 因为 80 端口别的占用了 开了7000 代理\r\n  server {\r\n    listen 7000;\r\n    server_name localhost;\r\n\r\n    location / {\r\n      proxy_pass http://node;\r\n    }\r\n\r\n  }\r\n}\r\n\r\n```\r\n\r\n```bash\r\nnginx -t\r\n\r\n# 如果没有启动先\r\nnginx\r\n\r\nnginx -s reload\r\n```\r\n\r\n因为 **egg** 定义的 **router** 返回了 **port** 直接访问 **127.0.0.1:7000** 可以查看结果 随机返回 **7001/7002**\r\n\r\n测试用了 **jmeter** 但是接口没异常 **jmeter** 倒是g了 使用不太熟练 请求次数太大了 但是效果还是可以看出来的","comments":{"nodes":[]},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"author":{"login":"xiaotiandada","url":"https://github.com/xiaotiandada","avatarUrl":"https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d&v=4"},"html":"<p>2020-07-10 14:39:18</p>\n<h2 id=\"一、负载均衡---初探\">一、负载均衡 - 初探</h2>\n<p><strong>资料参考:</strong> </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/89356016\">https://zhuanlan.zhihu.com/p/89356016</a></p>\n<p><a href=\"https://juejin.im/post/5e60edbf5188254940670f75\">https://juejin.im/post/5e60edbf5188254940670f75</a></p>\n<!-- more -->\n\n<p>服务器这边使用了 <strong>Nodejs</strong> 分别启两个服务 <strong>7001</strong> <strong>7002</strong>  和 两台机器 启动 <strong>7001</strong></p>\n<p><strong>Nginx</strong> 这边使用 <strong>upstream</strong> </p>\n<p>nginx的upstream目前支持的5种方式的分配</p>\n<p>1、轮询（默认） <strong>本地测试了这种</strong></p>\n<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\">upstream node { \n  server 127.0.0.1:7001; \n  server 127.0.0.1:7002; \n} </code></pre><p>2 - 4 没有测试过 复制的....</p>\n<p>2、指定权重</p>\n<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\">upstream backserver { \n  server 127.0.0.1:7001 weight=8; \n  server 127.0.0.1:7002 weight=10; \n} </code></pre><p>3、IP绑定 ip_hash</p>\n<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\">upstream backserver { \n  ip_hash; \n  server 127.0.0.1:7001; \n  server 127.0.0.1:7002; \n} </code></pre><p>4、fair（第三方）</p>\n<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\">upstream backserver { \n  server 127.0.0.1:7001; \n  server 127.0.0.1:7002; \n  fair; \n} </code></pre><p>5、url_hash（第三方）</p>\n<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\">upstream backserver { \n  server 127.0.0.1:7001; \n  server 127.0.0.1:7002; \n  hash $request_uri; \n  hash_method crc32; \n} </code></pre><blockquote>\n<p>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误</p>\n<p>fail_timeout:max_fails次失败后，暂停的时间 (复制的...</p>\n</blockquote>\n<p>在 <strong>Nginx</strong> 定义 测试机</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\">http {\n    upstream node {\n    server 127.0.0.1:7001;\n    server 192.168.1.11:7002;\n  }\n  \n  # 因为 80 端口别的占用了 开了7000 代理\n  server {\n    listen 7000;\n    server_name localhost;\n\n    location / {\n      proxy_pass http://node;\n    }\n\n  }\n}\n</code></pre><pre class=\"language-bash\"><code class=\"language-bash\">nginx -t\n\n# 如果没有启动先\nnginx\n\nnginx -s reload</code></pre><p>因为 <strong>egg</strong> 定义的 <strong>router</strong> 返回了 <strong>port</strong> 直接访问 <strong>127.0.0.1:7000</strong> 可以查看结果 随机返回 <strong>7001/7002</strong></p>\n<p>测试用了 <strong>jmeter</strong> 但是接口没异常 <strong>jmeter</strong> 倒是g了 使用不太熟练 请求次数太大了 但是效果还是可以看出来的</p>\n","attributes":{}},"themeConfig":{"title":"Blog(issues)","links":[{"title":"GitHub","url":"https://github.com/xiaotiandada/blog"},{"title":"Twitter","url":"https://twitter.com/XiaoTianIsMe"}]}},"__N_SSG":true}