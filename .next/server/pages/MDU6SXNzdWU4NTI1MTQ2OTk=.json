{"pageProps":{"post":{"id":"MDU6SXNzdWU4NTI1MTQ2OTk=","url":"https://github.com/xiaotiandada/blog/issues/78","title":"Vue Virtual Dom","updatedAt":"2022-04-05T17:33:16Z","createdAt":"2021-04-07T15:13:31Z","body":"[解析 snabbdom 源码，教你实现精简的 Virtual DOM 库](https://github.com/creeperyang/blog/issues/33)\r\n\r\n[snabbdom 源码阅读分析](https://juejin.cn/post/6844903671906435080#heading-1)\r\n\r\nhttps://juejin.cn/post/6844903831717806087\r\n\r\nhttps://gzg.me/posts/2021/snabbdom_source/\r\n\r\nhttps://www.cnblogs.com/xuntu/p/6800547.html\r\n\r\n>通常情况下，找到两棵任意的树之间最小修改的时间复杂度是 **O(n^3)**，这不可接受。幸好，我们可以对 Virtual DOM 树有这样的假设：\r\n>\r\n>如果 oldVnode 和 vnode 不同（如 type 从 `div` 变到 `p`，或者 `key` 改变），意味着整个 vnode 被替换（因为我们通常不会去跨层移动 vnode ），所以我们没有必要去比较 vnode 的 子 vnode（children） 了。基于这个假设，我们可以 **按照层级分解** 树，这大大简化了复杂度，大到接近 **O(n)** 的复杂度：\r\n>\r\n>![](https://user-images.githubusercontent.com/8046480/27190439-0a875688-5227-11e7-9015-eb34142de8ce.png)\r\n>\r\n>此外，对于 children （数组）的比较，因为同层是很可能有移动的，顺\r\n>序比较会无法最大化复用已有的 DOM。所以我们通过为每个 vnode 加上 key 来追踪这种顺序变动。\r\n>\r\n>![](https://user-images.githubusercontent.com/8046480/27191679-28085118-522b-11e7-92e9-fa0ed047f7cd.png)\r\n>\r\n>\r\n\r\n\r\n\r\n>- 用 js 对象来描述 dom 树结构，然后用这个 js 对象来创建一棵真正的 dom 树，插入到文档中\r\n>- 当状态更新时，将新的 js 对象和旧的 js 对象进行比较，得到两个对象之间的差异\r\n>- 将差异应用到真正的 dom 上\r\n\r\n\r\n\r\n### vnode\r\n\r\n```typescript\r\n// https://github.com/snabbdom/snabbdom/blob/master/src/vnode.ts\r\n// ...\r\nexport type Key = string | number | symbol;\r\n\r\nexport interface VNode {\r\n  sel: string | undefined;\r\n  data: VNodeData | undefined;\r\n  children: Array<VNode | string> | undefined;\r\n  elm: Node | undefined;\r\n  text: string | undefined;\r\n  key: Key | undefined;\r\n}\r\n\r\nexport interface VNodeData {\r\n  props?: Props;\r\n  attrs?: Attrs;\r\n  class?: Classes;\r\n  style?: VNodeStyle;\r\n  dataset?: Dataset;\r\n  on?: On;\r\n  attachData?: AttachData;\r\n  hook?: Hooks;\r\n  key?: Key;\r\n  ns?: string; // for SVGs\r\n  fn?: () => VNode; // for thunks\r\n  args?: any[]; // for thunks\r\n  is?: string; // for custom elements v1\r\n  [key: string]: any; // for any other 3rd party module\r\n}\r\n\r\nexport function vnode(\r\n  sel: string | undefined,\r\n  data: any | undefined,\r\n  children: Array<VNode | string> | undefined,\r\n  text: string | undefined,\r\n  elm: Element | Text | undefined\r\n): VNode {\r\n  const key = data === undefined ? undefined : data.key;\r\n  return { sel, data, children, text, elm, key };\r\n}\r\n```\r\n\r\n### init\r\n\r\n```typescript\r\n// https://github.com/snabbdom/snabbdom/blob/master/src/init.ts\r\nimport { Module } from \"./modules/module\";\r\nimport { vnode, VNode } from \"./vnode\";\r\nimport * as is from \"./is\";\r\nimport { htmlDomApi, DOMAPI } from \"./htmldomapi\";\r\n\r\ntype NonUndefined<T> = T extends undefined ? never : T;\r\n\r\nfunction isUndef(s: any): boolean {\r\n  return s === undefined;\r\n}\r\nfunction isDef<A>(s: A): s is NonUndefined<A> {\r\n  return s !== undefined;\r\n}\r\n\r\ntype VNodeQueue = VNode[];\r\n\r\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined);\r\n\r\nfunction sameVnode(vnode1: VNode, vnode2: VNode): boolean {\r\n  const isSameKey = vnode1.key === vnode2.key;\r\n  const isSameIs = vnode1.data?.is === vnode2.data?.is;\r\n  const isSameSel = vnode1.sel === vnode2.sel;\r\n\r\n  return isSameSel && isSameKey && isSameIs;\r\n}\r\n\r\nfunction isVnode(vnode: any): vnode is VNode {\r\n  return vnode.sel !== undefined;\r\n}\r\n\r\ntype KeyToIndexMap = { [key: string]: number };\r\n\r\ntype ArraysOf<T> = {\r\n  [K in keyof T]: Array<T[K]>;\r\n};\r\n\r\ntype ModuleHooks = ArraysOf<Required<Module>>;\r\n\r\nfunction createKeyToOldIdx(\r\n  children: VNode[],\r\n  beginIdx: number,\r\n  endIdx: number\r\n): KeyToIndexMap {\r\n  const map: KeyToIndexMap = {};\r\n  for (let i = beginIdx; i <= endIdx; ++i) {\r\n    const key = children[i]?.key;\r\n    if (key !== undefined) {\r\n      map[key as string] = i;\r\n    }\r\n  }\r\n  return map;\r\n}\r\n\r\nconst hooks: Array<keyof Module> = [\r\n  \"create\",\r\n  \"update\",\r\n  \"remove\",\r\n  \"destroy\",\r\n  \"pre\",\r\n  \"post\",\r\n];\r\n\r\nexport function init(modules: Array<Partial<Module>>, domApi?: DOMAPI) {\r\n  let i: number;\r\n  let j: number;\r\n  // 收集 module in the hook\r\n  const cbs: ModuleHooks = {\r\n    create: [],\r\n    update: [],\r\n    remove: [],\r\n    destroy: [],\r\n    pre: [],\r\n    post: [],\r\n  };\r\n\t\r\n  // 如果没有传递 domApi 使用浏览器中和 dom 相关的 api \r\n  // https://github.com/snabbdom/snabbdom/blob/master/src/htmldomapi.ts\r\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;\r\n\t\r\n  // 收集 module in the hook\r\n  for (i = 0; i < hooks.length; ++i) {\r\n    cbs[hooks[i]] = [];\r\n    for (j = 0; j < modules.length; ++j) {\r\n      const hook = modules[j][hooks[i]];\r\n      if (hook !== undefined) {\r\n        (cbs[hooks[i]] as any[]).push(hook);\r\n      }\r\n    }\r\n  }\r\n\r\n  function emptyNodeAt(elm: Element) {\r\n    const id = elm.id ? \"#\" + elm.id : \"\";\r\n\r\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\r\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\r\n    // weex https://github.com/vuejs/vue/blob/dev/src/platforms/weex/runtime/node-ops.js\r\n    const classes = elm.getAttribute(\"class\");\r\n\r\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\r\n    return vnode(\r\n      api.tagName(elm).toLowerCase() + id + c,\r\n      {},\r\n      [],\r\n      undefined,\r\n      elm\r\n    );\r\n  }\r\n\r\n  function createRmCb(childElm: Node, listeners: number) {\r\n    return function rmCb() {\r\n      if (--listeners === 0) {\r\n        const parent = api.parentNode(childElm) as Node;\r\n        api.removeChild(parent, childElm);\r\n      }\r\n    };\r\n  }\r\n\r\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\r\n    let i: any;\r\n    let data = vnode.data;\r\n    if (data !== undefined) {\r\n      const init = data.hook?.init;\r\n      if (isDef(init)) {\r\n        init(vnode);\r\n        data = vnode.data;\r\n      }\r\n    }\r\n    const children = vnode.children;\r\n    const sel = vnode.sel;\r\n    if (sel === \"!\") {\r\n      if (isUndef(vnode.text)) {\r\n        vnode.text = \"\";\r\n      }\r\n      vnode.elm = api.createComment(vnode.text!);\r\n    } else if (sel !== undefined) {\r\n      // Parse selector\r\n      const hashIdx = sel.indexOf(\"#\");\r\n      const dotIdx = sel.indexOf(\".\", hashIdx);\r\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\r\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\r\n      const tag =\r\n        hashIdx !== -1 || dotIdx !== -1\r\n          ? sel.slice(0, Math.min(hash, dot))\r\n          : sel;\r\n      const elm = (vnode.elm =\r\n        isDef(data) && isDef((i = data.ns))\r\n          ? api.createElementNS(i, tag, data)\r\n          : api.createElement(tag, data));\r\n      if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\r\n      if (dotIdx > 0)\r\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\r\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\r\n      if (is.array(children)) {\r\n        for (i = 0; i < children.length; ++i) {\r\n          const ch = children[i];\r\n          if (ch != null) {\r\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\r\n          }\r\n        }\r\n      } else if (is.primitive(vnode.text)) {\r\n        api.appendChild(elm, api.createTextNode(vnode.text));\r\n      }\r\n      const hook = vnode.data!.hook;\r\n      if (isDef(hook)) {\r\n        hook.create?.(emptyNode, vnode);\r\n        if (hook.insert) {\r\n          insertedVnodeQueue.push(vnode);\r\n        }\r\n      }\r\n    } else {\r\n      vnode.elm = api.createTextNode(vnode.text!);\r\n    }\r\n    return vnode.elm;\r\n  }\r\n\r\n  function addVnodes(\r\n    parentElm: Node,\r\n    before: Node | null,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\r\n      }\r\n    }\r\n  }\r\n\r\n  function invokeDestroyHook(vnode: VNode) {\r\n    const data = vnode.data;\r\n    if (data !== undefined) {\r\n      data?.hook?.destroy?.(vnode);\r\n      for (let i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\r\n      if (vnode.children !== undefined) {\r\n        for (let j = 0; j < vnode.children.length; ++j) {\r\n          const child = vnode.children[j];\r\n          if (child != null && typeof child !== \"string\") {\r\n            invokeDestroyHook(child);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeVnodes(\r\n    parentElm: Node,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number\r\n  ): void {\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n      let listeners: number;\r\n      let rm: () => void;\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        if (isDef(ch.sel)) {\r\n          invokeDestroyHook(ch);\r\n          listeners = cbs.remove.length + 1;\r\n          rm = createRmCb(ch.elm!, listeners);\r\n          for (let i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);\r\n          const removeHook = ch?.data?.hook?.remove;\r\n          if (isDef(removeHook)) {\r\n            removeHook(ch, rm);\r\n          } else {\r\n            rm();\r\n          }\r\n        } else {\r\n          // Text node\r\n          api.removeChild(parentElm, ch.elm!);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateChildren(\r\n    parentElm: Node,\r\n    oldCh: VNode[],\r\n    newCh: VNode[],\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    let oldStartIdx = 0;\r\n    let newStartIdx = 0;\r\n    let oldEndIdx = oldCh.length - 1;\r\n    let oldStartVnode = oldCh[0];\r\n    let oldEndVnode = oldCh[oldEndIdx];\r\n    let newEndIdx = newCh.length - 1;\r\n    let newStartVnode = newCh[0];\r\n    let newEndVnode = newCh[newEndIdx];\r\n    let oldKeyToIdx: KeyToIndexMap | undefined;\r\n    let idxInOld: number;\r\n    let elmToMove: VNode;\r\n    let before: any;\r\n\r\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n      if (oldStartVnode == null) {\r\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\r\n      } else if (oldEndVnode == null) {\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n      } else if (newStartVnode == null) {\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (newEndVnode == null) {\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n        // Vnode moved right\r\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\r\n        api.insertBefore(\r\n          parentElm,\r\n          oldStartVnode.elm!,\r\n          api.nextSibling(oldEndVnode.elm!)\r\n        );\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n        // Vnode moved left\r\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\r\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else {\r\n        if (oldKeyToIdx === undefined) {\r\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\r\n        if (isUndef(idxInOld)) {\r\n          // New element\r\n          api.insertBefore(\r\n            parentElm,\r\n            createElm(newStartVnode, insertedVnodeQueue),\r\n            oldStartVnode.elm!\r\n          );\r\n        } else {\r\n          elmToMove = oldCh[idxInOld];\r\n          if (elmToMove.sel !== newStartVnode.sel) {\r\n            api.insertBefore(\r\n              parentElm,\r\n              createElm(newStartVnode, insertedVnodeQueue),\r\n              oldStartVnode.elm!\r\n            );\r\n          } else {\r\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\r\n            oldCh[idxInOld] = undefined as any;\r\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\r\n          }\r\n        }\r\n        newStartVnode = newCh[++newStartIdx];\r\n      }\r\n    }\r\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\r\n      if (oldStartIdx > oldEndIdx) {\r\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\r\n        addVnodes(\r\n          parentElm,\r\n          before,\r\n          newCh,\r\n          newStartIdx,\r\n          newEndIdx,\r\n          insertedVnodeQueue\r\n        );\r\n      } else {\r\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\r\n      }\r\n    }\r\n  }\r\n\r\n  function patchVnode(\r\n    oldVnode: VNode,\r\n    vnode: VNode,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    const hook = vnode.data?.hook;\r\n    hook?.prepatch?.(oldVnode, vnode);\r\n    const elm = (vnode.elm = oldVnode.elm)!;\r\n    const oldCh = oldVnode.children as VNode[];\r\n    const ch = vnode.children as VNode[];\r\n    if (oldVnode === vnode) return;\r\n    if (vnode.data !== undefined) {\r\n      for (let i = 0; i < cbs.update.length; ++i)\r\n        cbs.update[i](oldVnode, vnode);\r\n      vnode.data.hook?.update?.(oldVnode, vnode);\r\n    }\r\n    if (isUndef(vnode.text)) {\r\n      if (isDef(oldCh) && isDef(ch)) {\r\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\r\n      } else if (isDef(ch)) {\r\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\r\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n      } else if (isDef(oldCh)) {\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      } else if (isDef(oldVnode.text)) {\r\n        api.setTextContent(elm, \"\");\r\n      }\r\n    } else if (oldVnode.text !== vnode.text) {\r\n      if (isDef(oldCh)) {\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      }\r\n      api.setTextContent(elm, vnode.text!);\r\n    }\r\n    hook?.postpatch?.(oldVnode, vnode);\r\n  }\r\n\r\n  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\r\n    let i: number, elm: Node, parent: Node;\r\n    const insertedVnodeQueue: VNodeQueue = [];\r\n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();\r\n\r\n    if (!isVnode(oldVnode)) {\r\n      oldVnode = emptyNodeAt(oldVnode);\r\n    }\r\n\r\n    if (sameVnode(oldVnode, vnode)) {\r\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\r\n    } else {\r\n      elm = oldVnode.elm!;\r\n      parent = api.parentNode(elm) as Node;\r\n\r\n      createElm(vnode, insertedVnodeQueue);\r\n\r\n      if (parent !== null) {\r\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\r\n        removeVnodes(parent, [oldVnode], 0, 0);\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\r\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\r\n    }\r\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();\r\n    return vnode;\r\n  };\r\n}\r\n\r\n```\r\n\r\n### h\r\n\r\n```typescript\r\nimport { vnode, VNode, VNodeData } from \"./vnode\";\r\nimport * as is from \"./is\";\r\n\r\nexport type VNodes = VNode[];\r\nexport type VNodeChildElement = VNode | string | number | undefined | null;\r\nexport type ArrayOrElement<T> = T | T[];\r\nexport type VNodeChildren = ArrayOrElement<VNodeChildElement>;\r\n\r\nfunction addNS(\r\n  data: any,\r\n  children: VNodes | undefined,\r\n  sel: string | undefined\r\n): void {\r\n  data.ns = \"http://www.w3.org/2000/svg\";\r\n  if (sel !== \"foreignObject\" && children !== undefined) {\r\n    for (let i = 0; i < children.length; ++i) {\r\n      const childData = children[i].data;\r\n      if (childData !== undefined) {\r\n        addNS(childData, children[i].children as VNodes, children[i].sel);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function h(sel: string): VNode;\r\nexport function h(sel: string, data: VNodeData | null): VNode;\r\nexport function h(sel: string, children: VNodeChildren): VNode;\r\nexport function h(\r\n  sel: string,\r\n  data: VNodeData | null,\r\n  children: VNodeChildren\r\n): VNode;\r\nexport function h(sel: any, b?: any, c?: any): VNode {\r\n  let data: VNodeData = {};\r\n  let children: any;\r\n  let text: any;\r\n  let i: number;\r\n  // c 不为空 可能是 [] / string\r\n  if (c !== undefined) {\r\n    // b 不为空 有 {} options (认为是 VNodeData)\r\n    if (b !== null) {\r\n      data = b;\r\n    }\r\n    // 如果 c 是 []\r\n    if (is.array(c)) {\r\n      children = c;\r\n    } else if (is.primitive(c)) { // c 是 string / number 应该认为是 text node\r\n      text = c;\r\n    } else if (c && c.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ c ]\r\n      children = [c];\r\n    }\r\n  } else if (b !== undefined && b !== null) { // 如果是 b 不为空\r\n    // 如果是 array 说明是 VNodeChildren\r\n    if (is.array(b)) {\r\n      children = b;\r\n    } else if (is.primitive(b)) { // 如果是 string/number 应该认为是 text node\r\n      text = b;\r\n    } else if (b && b.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ b ]\r\n      children = [b];\r\n    } else { // 认为 b 是 VNodeData\r\n      data = b;\r\n    }\r\n  }\r\n  // 如果存在 children\r\n  if (children !== undefined) {\r\n    for (i = 0; i < children.length; ++i) {\r\n      // 如果每个 children 是 string/number 转换成 vnode\r\n      if (is.primitive(children[i]))\r\n        children[i] = vnode(\r\n          undefined,\r\n          undefined,\r\n          undefined,\r\n          children[i],\r\n          undefined\r\n        );\r\n    }\r\n  }\r\n  // 如果是 svg 添加 namespace\r\n  if (\r\n    sel[0] === \"s\" &&\r\n    sel[1] === \"v\" &&\r\n    sel[2] === \"g\" &&\r\n    (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")\r\n  ) {\r\n    addNS(data, children, sel);\r\n  }\r\n  return vnode(sel, data, children, text, undefined);\r\n}\r\n```\r\n\r\n### patch\r\n\r\n```typescript\r\n// 调用 init 返回 patch  \r\n\r\n  function emptyNodeAt(elm: Element) {\r\n    const id = elm.id ? \"#\" + elm.id : \"\";\r\n\r\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\r\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\r\n    const classes = elm.getAttribute(\"class\");\r\n\r\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\r\n    // document.querySelector('div').tagName => DIV\r\n    // div#id.classa.classb / div#id / div.class / div\r\n    return vnode(\r\n      api.tagName(elm).toLowerCase() + id + c,\r\n      {},\r\n      [],\r\n      undefined,\r\n      elm\r\n    );\r\n  }\r\n\r\nreturn function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\r\n    let i: number, elm: Node, parent: Node;\r\n    const insertedVnodeQueue: VNodeQueue = [];\r\n\t  // 调用 module 中的 pre hook \r\n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();\r\n\t\t\r\n\t  // 如果 oldVnode 是 Element 转换为空的 vnode\r\n    if (!isVnode(oldVnode)) {\r\n      oldVnode = emptyNodeAt(oldVnode);\r\n    }\r\n\t\t\t\r\n   \t// > 如果相同，调用 patchVnode，如果不相同，会调用 createElm 来创建一个新的 dom 节点，然后如果存在父节点，便将其插入到 dom 上，然后移除旧的 dom 节点来完成更新。\r\n  \r\n\t  // oldVnode vnode sel key is 相同\r\n    if (sameVnode(oldVnode, vnode)) {\r\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\r\n    } else {\r\n      elm = oldVnode.elm!;\r\n      // ele parentNode\r\n      parent = api.parentNode(elm) as Node;\r\n\t\t\t// 创建\r\n      createElm(vnode, insertedVnodeQueue);\r\n\t\t\t\r\n      // 有父节点\r\n      if (parent !== null) {\r\n        // insert dom\r\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\r\n        // remove vnode\r\n        removeVnodes(parent, [oldVnode], 0, 0);\r\n      }\r\n    }\r\n\t\t\r\n  // 调用元素上的 insert hook，insert  hook 在 module 上不支持\r\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\r\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\r\n    }\r\n\t  // 调用 module post hook\r\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();\r\n    return vnode;\r\n  };\r\n```\r\n\r\n>The following hooks are available for modules: `pre`, `create`, `update`, `destroy`, `remove`, `post`\r\n>\r\n>The following hooks are available in the `hook` property of individual elements: `init`, `create`, `insert`, `prepatch`, `update`, `postpatch`, `destroy`, `remove`.\r\n\r\n### createElm\r\n\r\n```typescript\r\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\r\n    let i: any;\r\n    let data = vnode.data;\r\n    // 调用元素的 init hook\r\n    if (data !== undefined) {\r\n      const init = data.hook?.init;\r\n      if (isDef(init)) {\r\n        init(vnode);\r\n        data = vnode.data;\r\n      }\r\n    }\r\n    const children = vnode.children;\r\n    \r\n    // 创建注释节点\r\n    const sel = vnode.sel;\r\n    if (sel === \"!\") {\r\n      if (isUndef(vnode.text)) {\r\n        vnode.text = \"\";\r\n      }\r\n      vnode.elm = api.createComment(vnode.text!);\r\n    } else if (sel !== undefined) {\r\n      // Parse selector\r\n      const hashIdx = sel.indexOf(\"#\");\r\n      const dotIdx = sel.indexOf(\".\", hashIdx);\r\n      // div#box\r\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\r\n      // div.boxclass\r\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\r\n      const tag =\r\n        hashIdx !== -1 || dotIdx !== -1\r\n          ? sel.slice(0, Math.min(hash, dot))\r\n          : sel;\r\n      const elm = (vnode.elm =\r\n        isDef(data) && isDef((i = data.ns))\r\n          ? api.createElementNS(i, tag, data)\r\n          : api.createElement(tag, data));\r\n      if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\r\n      if (dotIdx > 0)\r\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\r\n      // 调用 module 的 create hook\r\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\r\n      // 挂在子节点\r\n      if (is.array(children)) {\r\n        for (i = 0; i < children.length; ++i) {\r\n          const ch = children[i];\r\n          if (ch != null) {\r\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\r\n          }\r\n        }\r\n      } else if (is.primitive(vnode.text)) {\r\n        // 插入 文本节点\r\n        api.appendChild(elm, api.createTextNode(vnode.text));\r\n      }\r\n      // 执行 vnode data hook\r\n      const hook = vnode.data!.hook;\r\n      if (isDef(hook)) {\r\n        // 执行 hook create\r\n        hook.create?.(emptyNode, vnode);\r\n        if (hook.insert) {\r\n          // insert hook 存储起来 等 dom 插入后才会调用，这里用个数组来保存能避免调用时再次对 vnode 树做遍历\r\n          insertedVnodeQueue.push(vnode);\r\n        }\r\n      }\r\n    } else {\r\n      // 文本节点\r\n      vnode.elm = api.createTextNode(vnode.text!);\r\n    }\r\n    return vnode.elm;\r\n  }\r\n```\r\n\r\n\r\n\r\n### patchVnode\r\n\r\n```typescript\r\nfunction patchVnode(\r\n    oldVnode: VNode,\r\n    vnode: VNode,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    const hook = vnode.data?.hook;\r\n    // 执行 prepatch hook\r\n    hook?.prepatch?.(oldVnode, vnode);\r\n    const elm = (vnode.elm = oldVnode.elm)!;\r\n    const oldCh = oldVnode.children as VNode[];\r\n    const ch = vnode.children as VNode[];\r\n     // 新 旧 vnode 相同\r\n    if (oldVnode === vnode) return;\r\n    // 执行 cbs update hook，vnode update hook\r\n    if (vnode.data !== undefined) {\r\n      for (let i = 0; i < cbs.update.length; ++i)\r\n        cbs.update[i](oldVnode, vnode);\r\n      vnode.data.hook?.update?.(oldVnode, vnode);\r\n    }\r\n    // 是没有定义的\r\n    if (isUndef(vnode.text)) {\r\n      // 均存在 children 且不相同，调用 updateChildren\r\n    \r\n      // 定义过 children\r\n      if (isDef(oldCh) && isDef(ch)) {\r\n        // old children 不等于 new children\r\n        // 更新 updateChildren\r\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\r\n      } else if (isDef(ch)) { // 只定义了 new children\r\n        // 新 vnode 存在 children，旧 vnode 不存在 children，如果旧 vnode 存在 text 先清空，然后调用 addVnodes\r\n        \r\n        // 如果是 text，设置内容\r\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\r\n        // 添加 vnode\r\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n      } else if (isDef(oldCh)) { // 只定义 old children\r\n        // 新 vnode 不存在 children，旧 vnode 存在 children，调用 removeVnodes 移除 children\r\n        \r\n        // 移除 vnode\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      } else if (isDef(oldVnode.text)) { // 只定义了 old vnode text\r\n        // 设置内容\r\n        api.setTextContent(elm, \"\");\r\n      }\r\n    } else if (oldVnode.text !== vnode.text) { // old vnode text 和 new vnode text 不一样\r\n      // 均不存在 children，新 vnode 不存在 text，移除旧 vnode 的 text\r\n      \r\n      // 如果定义了 old children\r\n      if (isDef(oldCh)) {\r\n        // 移除\r\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\r\n      }\r\n      // 均存在 text，更新 text\r\n      \r\n      // 设置新内容\r\n      api.setTextContent(elm, vnode.text!);\r\n    }\r\n    // 执行 postpatch hook\r\n    hook?.postpatch?.(oldVnode, vnode);\r\n  }\r\n```\r\n\r\n### updateChildren\r\n\r\n```typescript\r\n  function updateChildren(\r\n    parentElm: Node,\r\n    oldCh: VNode[],\r\n    newCh: VNode[],\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    let oldStartIdx = 0; // 旧 头 索引\r\n    let newStartIdx = 0; // 新 头 索引\r\n    let oldEndIdx = oldCh.length - 1; // 旧 尾 索引\r\n    let oldStartVnode = oldCh[0]; // 旧 头 Vnode\r\n    let oldEndVnode = oldCh[oldEndIdx]; // 旧 尾 Vnode\r\n    let newEndIdx = newCh.length - 1; // 新 尾 索引\r\n    let newStartVnode = newCh[0]; // 新 头 Vnode\r\n    let newEndVnode = newCh[newEndIdx]; // 新 尾 Vnode\r\n    let oldKeyToIdx: KeyToIndexMap | undefined;\r\n    let idxInOld: number;\r\n    let elmToMove: VNode;\r\n    let before: any;\r\n\r\n    // 循环 从 头 到 尾 处理（新/旧）\r\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n      // 如果 头尾（新/旧）其中有为 null 重新赋值，并且为元素数组中 添加/减少 一位\r\n      if (oldStartVnode == null) {\r\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\r\n      } else if (oldEndVnode == null) {\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n      } else if (newStartVnode == null) {\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (newEndVnode == null) {\r\n        newEndVnode = newCh[--newEndIdx];\r\n\r\n        // 如果相同 对比 新/旧 内容变化然后更新 DOM\r\n        // 新/旧 头Vnode 赋值\r\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n\r\n        // 节点移动到右边 更新 DOM\r\n        // 把更新的内容移动插入到旧节点最后\r\n        // 旧头索引 ++\r\n        // 新尾索引 --\r\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n        // Vnode moved right\r\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\r\n        api.insertBefore(\r\n          parentElm,\r\n          oldStartVnode.elm!,\r\n          api.nextSibling(oldEndVnode.elm!)\r\n        );\r\n        oldStartVnode = oldCh[++oldStartIdx];\r\n        newEndVnode = newCh[--newEndIdx];\r\n\r\n        // 节点移动到左边 更新 DOM\r\n        // 把更新的内容移动插入到旧节点最前\r\n        // 旧尾 --\r\n        // 新头 ++\r\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n        // Vnode moved left\r\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\r\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\r\n        oldEndVnode = oldCh[--oldEndIdx];\r\n        newStartVnode = newCh[++newStartIdx];\r\n\r\n\r\n        // 如果不是以上情况\r\n        // 开始节点是一个新节点\r\n        // 如果没有 key，创建 DOM 插入到前方\r\n        // 如果有 key，判断 sel 是否相同，如果不同创建 DOM 如果相同则代表是相同节点\r\n      } else {\r\n\r\n        // 方便通过新节点的key找到旧节点数组的索引\r\n        if (oldKeyToIdx === undefined) {\r\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n        // 用新节点的key 找到老节点的索引\r\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\r\n\r\n        // 如果是新节点\r\n        if (isUndef(idxInOld)) {\r\n          // New element\r\n          api.insertBefore(\r\n            parentElm,\r\n            createElm(newStartVnode, insertedVnodeQueue),\r\n            oldStartVnode.elm!\r\n          );\r\n        } else {\r\n          // 旧节点\r\n          // 取出旧节点\r\n          elmToMove = oldCh[idxInOld];\r\n          // 新元素 直接创建一个新的插入\r\n          if (elmToMove.sel !== newStartVnode.sel) {\r\n            api.insertBefore(\r\n              parentElm,\r\n              createElm(newStartVnode, insertedVnodeQueue),\r\n              oldStartVnode.elm!\r\n            );\r\n          } else {\r\n            // 没有修改过 更新内部 DOM\r\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\r\n            // 把旧节点相应位置的元素设置为undefined\r\n            oldCh[idxInOld] = undefined as any;\r\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\r\n          }\r\n        }\r\n        // 插入完成后，索引增加\r\n        newStartVnode = newCh[++newStartIdx];\r\n      }\r\n    }\r\n\r\n    // 老节点 或 新节点遍历完成\r\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\r\n      if (oldStartIdx > oldEndIdx) {\r\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\r\n        addVnodes(\r\n          parentElm,\r\n          before,\r\n          newCh,\r\n          newStartIdx,\r\n          newEndIdx,\r\n          insertedVnodeQueue\r\n        );\r\n      } else {\r\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n### addVnodes\r\n\r\n```typescript\r\n  function addVnodes(\r\n    parentElm: Node,\r\n    before: Node | null,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number,\r\n    insertedVnodeQueue: VNodeQueue\r\n  ) {\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n### removeVnodes\r\n\r\n```typescript\r\n\r\n  function removeVnodes(\r\n    parentElm: Node,\r\n    vnodes: VNode[],\r\n    startIdx: number,\r\n    endIdx: number\r\n  ): void {\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n      let listeners: number;\r\n      let rm: () => void;\r\n      const ch = vnodes[startIdx];\r\n      if (ch != null) {\r\n        if (isDef(ch.sel)) {\r\n          // ˙执行 ch data destroy hook\r\n          invokeDestroyHook(ch);\r\n          listeners = cbs.remove.length + 1;\r\n          rm = createRmCb(ch.elm!, listeners);\r\n          // 调用 module 中是 remove hook\r\n          for (let i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);\r\n           // 调用 vnode 的 remove hook\r\n          const removeHook = ch?.data?.hook?.remove;\r\n          if (isDef(removeHook)) {\r\n            removeHook(ch, rm);\r\n          } else {\r\n            rm();\r\n          }\r\n        } else {\r\n          // Text node\r\n          api.removeChild(parentElm, ch.elm!);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n// 调用 destroy hook\r\nfunction invokeDestroyHook(vnode: VNode) {\r\n  const data = vnode.data;\r\n  if (data !== undefined) {\r\n    data?.hook?.destroy?.(vnode);\r\n    for (let i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\r\n    if (vnode.children !== undefined) {\r\n      for (let j = 0; j < vnode.children.length; ++j) {\r\n        const child = vnode.children[j];\r\n        if (child != null && typeof child !== \"string\") {\r\n          invokeDestroyHook(child);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\nfunction createRmCb(childElm: Node, listeners: number) {\r\n  return function rmCb() {\r\n    if (--listeners === 0) {\r\n      const parent = api.parentNode(childElm) as Node;\r\n      api.removeChild(parent, childElm);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### createElm\r\n\r\n```typescript\r\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\r\n    let i: any;\r\n    let data = vnode.data;\r\n    if (data !== undefined) {\r\n      // 调用 init hook\r\n      const init = data.hook?.init;\r\n      if (isDef(init)) {\r\n        init(vnode);\r\n        data = vnode.data;\r\n      }\r\n    }\r\n    const children = vnode.children;\r\n    const sel = vnode.sel;\r\n    if (sel === \"!\") { // 注释\r\n      if (isUndef(vnode.text)) {\r\n        vnode.text = \"\";\r\n      }\r\n      vnode.elm = api.createComment(vnode.text!);\r\n    } else if (sel !== undefined) {\r\n      // Parse selector\r\n      const hashIdx = sel.indexOf(\"#\");\r\n      const dotIdx = sel.indexOf(\".\", hashIdx);\r\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\r\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\r\n      const tag =\r\n        hashIdx !== -1 || dotIdx !== -1\r\n          ? sel.slice(0, Math.min(hash, dot))\r\n          : sel;\r\n      const elm = (vnode.elm =\r\n        isDef(data) && isDef((i = data.ns))\r\n          ? api.createElementNS(i, tag, data)\r\n          : api.createElement(tag, data));\r\n      if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\r\n      if (dotIdx > 0)\r\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\r\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\r\n      if (is.array(children)) {\r\n        for (i = 0; i < children.length; ++i) {\r\n          const ch = children[i];\r\n          if (ch != null) {\r\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\r\n          }\r\n        }\r\n      } else if (is.primitive(vnode.text)) {\r\n        api.appendChild(elm, api.createTextNode(vnode.text));\r\n      }\r\n      // 调用 create hook\r\n      const hook = vnode.data!.hook;\r\n      if (isDef(hook)) {\r\n        hook.create?.(emptyNode, vnode);\r\n        if (hook.insert) {\r\n          insertedVnodeQueue.push(vnode);\r\n        }\r\n      }\r\n    } else {\r\n      vnode.elm = api.createTextNode(vnode.text!);\r\n    }\r\n    return vnode.elm;\r\n  }\r\n```\r\n\r\n### thunk\r\n\r\n```typescript\r\nexport interface ThunkData extends VNodeData {\r\n  fn: () => VNode;\r\n  args: any[];\r\n}\r\n\r\nexport interface Thunk extends VNode {\r\n  data: ThunkData;\r\n}\r\n\r\nexport interface ThunkFn {\r\n  (sel: string, fn: (...args: any[]) => any, args: any[]): Thunk;\r\n  (sel: string, key: any, fn: (...args: any[]) => any, args: any[]): Thunk;\r\n}\r\n\r\n// thunk  fn 、 args 属性保存到 vnode 上，在 prepatch 时需要进行比较\r\n// 将 vnode 上的数据拷贝到 thunk 上， patchVnode 中判断，相同会结束 patchVnode\r\nfunction copyToThunk(vnode: VNode, thunk: VNode): void {\r\n  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;\r\n  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;\r\n  thunk.data = vnode.data;\r\n  thunk.children = vnode.children;\r\n  thunk.text = vnode.text;\r\n  thunk.elm = vnode.elm;\r\n}\r\n\r\nfunction init(thunk: VNode): void {\r\n  const cur = thunk.data as VNodeData;\r\n  const vnode = (cur.fn as any)(...cur.args!);\r\n  copyToThunk(vnode, thunk);\r\n}\r\n\r\nfunction prepatch(oldVnode: VNode, thunk: VNode): void {\r\n  let i: number;\r\n  const old = oldVnode.data as VNodeData;\r\n  const cur = thunk.data as VNodeData;\r\n  const oldArgs = old.args;\r\n  const args = cur.args;\r\n  //  如果 fn 不同或 args 长度不同，说明发生了变化，调用 fn 生成新的 vnode 并返回\r\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\r\n    copyToThunk((cur.fn as any)(...args!), thunk);\r\n    return;\r\n  }\r\n  // 如果每个参数发生变化，逻辑同上\r\n  for (i = 0; i < (args as any).length; ++i) {\r\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\r\n      copyToThunk((cur.fn as any)(...args!), thunk);\r\n      return;\r\n    }\r\n  }\r\n  copyToThunk(oldVnode, thunk);\r\n}\r\n// 使用 h 返回 vnode\r\n// 添加 init prepatch hook\r\nexport const thunk = function thunk(\r\n  sel: string,\r\n  key?: any,\r\n  fn?: any,\r\n  args?: any\r\n): VNode {\r\n  if (args === undefined) {\r\n    args = fn;\r\n    fn = key;\r\n    key = undefined;\r\n  }\r\n  return h(sel, {\r\n    key: key,\r\n    hook: { init, prepatch },\r\n    fn: fn,\r\n    args: args,\r\n  });\r\n} as ThunkFn;\r\n\r\n```\r\n\r\n","comments":{"nodes":[]},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"author":{"login":"xiaotiandada","url":"https://github.com/xiaotiandada","avatarUrl":"https://avatars.githubusercontent.com/u/24250627?u=51a93e07957381123eb9fbdd6407de36033b578d&v=4"},"html":"<p><a href=\"https://github.com/creeperyang/blog/issues/33\">解析 snabbdom 源码，教你实现精简的 Virtual DOM 库</a></p>\n<p><a href=\"https://juejin.cn/post/6844903671906435080#heading-1\">snabbdom 源码阅读分析</a></p>\n<p><a href=\"https://juejin.cn/post/6844903831717806087\">https://juejin.cn/post/6844903831717806087</a></p>\n<p><a href=\"https://gzg.me/posts/2021/snabbdom_source/\">https://gzg.me/posts/2021/snabbdom_source/</a></p>\n<p><a href=\"https://www.cnblogs.com/xuntu/p/6800547.html\">https://www.cnblogs.com/xuntu/p/6800547.html</a></p>\n<blockquote>\n<p>通常情况下，找到两棵任意的树之间最小修改的时间复杂度是 **O(n^3)**，这不可接受。幸好，我们可以对 Virtual DOM 树有这样的假设：</p>\n<p>如果 oldVnode 和 vnode 不同（如 type 从 <code>div</code> 变到 <code>p</code>，或者 <code>key</code> 改变），意味着整个 vnode 被替换（因为我们通常不会去跨层移动 vnode ），所以我们没有必要去比较 vnode 的 子 vnode（children） 了。基于这个假设，我们可以 <strong>按照层级分解</strong> 树，这大大简化了复杂度，大到接近 <strong>O(n)</strong> 的复杂度：</p>\n<p><img src=\"https://user-images.githubusercontent.com/8046480/27190439-0a875688-5227-11e7-9015-eb34142de8ce.png\" alt=\"\"></p>\n<p>此外，对于 children （数组）的比较，因为同层是很可能有移动的，顺\n序比较会无法最大化复用已有的 DOM。所以我们通过为每个 vnode 加上 key 来追踪这种顺序变动。</p>\n<p><img src=\"https://user-images.githubusercontent.com/8046480/27191679-28085118-522b-11e7-92e9-fa0ed047f7cd.png\" alt=\"\"></p>\n</blockquote>\n<blockquote>\n<ul>\n<li>用 js 对象来描述 dom 树结构，然后用这个 js 对象来创建一棵真正的 dom 树，插入到文档中</li>\n<li>当状态更新时，将新的 js 对象和旧的 js 对象进行比较，得到两个对象之间的差异</li>\n<li>将差异应用到真正的 dom 上</li>\n</ul>\n</blockquote>\n<h3 id=\"vnode\">vnode</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">// https://github.com/snabbdom/snabbdom/blob/master/src/vnode.ts\n// ...\nexport type Key = string | number | symbol;\n\nexport interface VNode {\n  sel: string | undefined;\n  data: VNodeData | undefined;\n  children: Array<VNode | string> | undefined;\n  elm: Node | undefined;\n  text: string | undefined;\n  key: Key | undefined;\n}\n\nexport interface VNodeData {\n  props?: Props;\n  attrs?: Attrs;\n  class?: Classes;\n  style?: VNodeStyle;\n  dataset?: Dataset;\n  on?: On;\n  attachData?: AttachData;\n  hook?: Hooks;\n  key?: Key;\n  ns?: string; // for SVGs\n  fn?: () => VNode; // for thunks\n  args?: any[]; // for thunks\n  is?: string; // for custom elements v1\n  [key: string]: any; // for any other 3rd party module\n}\n\nexport function vnode(\n  sel: string | undefined,\n  data: any | undefined,\n  children: Array<VNode | string> | undefined,\n  text: string | undefined,\n  elm: Element | Text | undefined\n): VNode {\n  const key = data === undefined ? undefined : data.key;\n  return { sel, data, children, text, elm, key };\n}</code></pre><h3 id=\"init\">init</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">// https://github.com/snabbdom/snabbdom/blob/master/src/init.ts\nimport { Module } from \"./modules/module\";\nimport { vnode, VNode } from \"./vnode\";\nimport * as is from \"./is\";\nimport { htmlDomApi, DOMAPI } from \"./htmldomapi\";\n\ntype NonUndefined<T> = T extends undefined ? never : T;\n\nfunction isUndef(s: any): boolean {\n  return s === undefined;\n}\nfunction isDef<A>(s: A): s is NonUndefined<A> {\n  return s !== undefined;\n}\n\ntype VNodeQueue = VNode[];\n\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined);\n\nfunction sameVnode(vnode1: VNode, vnode2: VNode): boolean {\n  const isSameKey = vnode1.key === vnode2.key;\n  const isSameIs = vnode1.data?.is === vnode2.data?.is;\n  const isSameSel = vnode1.sel === vnode2.sel;\n\n  return isSameSel && isSameKey && isSameIs;\n}\n\nfunction isVnode(vnode: any): vnode is VNode {\n  return vnode.sel !== undefined;\n}\n\ntype KeyToIndexMap = { [key: string]: number };\n\ntype ArraysOf<T> = {\n  [K in keyof T]: Array<T[K]>;\n};\n\ntype ModuleHooks = ArraysOf<Required<Module>>;\n\nfunction createKeyToOldIdx(\n  children: VNode[],\n  beginIdx: number,\n  endIdx: number\n): KeyToIndexMap {\n  const map: KeyToIndexMap = {};\n  for (let i = beginIdx; i <= endIdx; ++i) {\n    const key = children[i]?.key;\n    if (key !== undefined) {\n      map[key as string] = i;\n    }\n  }\n  return map;\n}\n\nconst hooks: Array<keyof Module> = [\n  \"create\",\n  \"update\",\n  \"remove\",\n  \"destroy\",\n  \"pre\",\n  \"post\",\n];\n\nexport function init(modules: Array<Partial<Module>>, domApi?: DOMAPI) {\n  let i: number;\n  let j: number;\n  // 收集 module in the hook\n  const cbs: ModuleHooks = {\n    create: [],\n    update: [],\n    remove: [],\n    destroy: [],\n    pre: [],\n    post: [],\n  };\n    \n  // 如果没有传递 domApi 使用浏览器中和 dom 相关的 api \n  // https://github.com/snabbdom/snabbdom/blob/master/src/htmldomapi.ts\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;\n    \n  // 收集 module in the hook\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      const hook = modules[j][hooks[i]];\n      if (hook !== undefined) {\n        (cbs[hooks[i]] as any[]).push(hook);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm: Element) {\n    const id = elm.id ? \"#\" + elm.id : \"\";\n\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n    // weex https://github.com/vuejs/vue/blob/dev/src/platforms/weex/runtime/node-ops.js\n    const classes = elm.getAttribute(\"class\");\n\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n    return vnode(\n      api.tagName(elm).toLowerCase() + id + c,\n      {},\n      [],\n      undefined,\n      elm\n    );\n  }\n\n  function createRmCb(childElm: Node, listeners: number) {\n    return function rmCb() {\n      if (--listeners === 0) {\n        const parent = api.parentNode(childElm) as Node;\n        api.removeChild(parent, childElm);\n      }\n    };\n  }\n\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any;\n    let data = vnode.data;\n    if (data !== undefined) {\n      const init = data.hook?.init;\n      if (isDef(init)) {\n        init(vnode);\n        data = vnode.data;\n      }\n    }\n    const children = vnode.children;\n    const sel = vnode.sel;\n    if (sel === \"!\") {\n      if (isUndef(vnode.text)) {\n        vnode.text = \"\";\n      }\n      vnode.elm = api.createComment(vnode.text!);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf(\"#\");\n      const dotIdx = sel.indexOf(\".\", hashIdx);\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\n      const tag =\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel;\n      const elm = (vnode.elm =\n        isDef(data) && isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data));\n      if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n      if (dotIdx > 0)\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      const hook = vnode.data!.hook;\n      if (isDef(hook)) {\n        hook.create?.(emptyNode, vnode);\n        if (hook.insert) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } else {\n      vnode.elm = api.createTextNode(vnode.text!);\n    }\n    return vnode.elm;\n  }\n\n  function addVnodes(\n    parentElm: Node,\n    before: Node | null,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n      }\n    }\n  }\n\n  function invokeDestroyHook(vnode: VNode) {\n    const data = vnode.data;\n    if (data !== undefined) {\n      data?.hook?.destroy?.(vnode);\n      for (let i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n      if (vnode.children !== undefined) {\n        for (let j = 0; j < vnode.children.length; ++j) {\n          const child = vnode.children[j];\n          if (child != null && typeof child !== \"string\") {\n            invokeDestroyHook(child);\n          }\n        }\n      }\n    }\n  }\n\n  function removeVnodes(\n    parentElm: Node,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number\n  ): void {\n    for (; startIdx <= endIdx; ++startIdx) {\n      let listeners: number;\n      let rm: () => void;\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        if (isDef(ch.sel)) {\n          invokeDestroyHook(ch);\n          listeners = cbs.remove.length + 1;\n          rm = createRmCb(ch.elm!, listeners);\n          for (let i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);\n          const removeHook = ch?.data?.hook?.remove;\n          if (isDef(removeHook)) {\n            removeHook(ch, rm);\n          } else {\n            rm();\n          }\n        } else {\n          // Text node\n          api.removeChild(parentElm, ch.elm!);\n        }\n      }\n    }\n  }\n\n  function updateChildren(\n    parentElm: Node,\n    oldCh: VNode[],\n    newCh: VNode[],\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx: KeyToIndexMap | undefined;\n    let idxInOld: number;\n    let elmToMove: VNode;\n    let before: any;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (oldStartVnode == null) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n      } else if (oldEndVnode == null) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (newStartVnode == null) {\n        newStartVnode = newCh[++newStartIdx];\n      } else if (newEndVnode == null) {\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(\n          parentElm,\n          oldStartVnode.elm!,\n          api.nextSibling(oldEndVnode.elm!)\n        );\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (oldKeyToIdx === undefined) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\n        if (isUndef(idxInOld)) {\n          // New element\n          api.insertBefore(\n            parentElm,\n            createElm(newStartVnode, insertedVnodeQueue),\n            oldStartVnode.elm!\n          );\n        } else {\n          elmToMove = oldCh[idxInOld];\n          if (elmToMove.sel !== newStartVnode.sel) {\n            api.insertBefore(\n              parentElm,\n              createElm(newStartVnode, insertedVnodeQueue),\n              oldStartVnode.elm!\n            );\n          } else {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined as any;\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n      if (oldStartIdx > oldEndIdx) {\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(\n          parentElm,\n          before,\n          newCh,\n          newStartIdx,\n          newEndIdx,\n          insertedVnodeQueue\n        );\n      } else {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n  }\n\n  function patchVnode(\n    oldVnode: VNode,\n    vnode: VNode,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    const hook = vnode.data?.hook;\n    hook?.prepatch?.(oldVnode, vnode);\n    const elm = (vnode.elm = oldVnode.elm)!;\n    const oldCh = oldVnode.children as VNode[];\n    const ch = vnode.children as VNode[];\n    if (oldVnode === vnode) return;\n    if (vnode.data !== undefined) {\n      for (let i = 0; i < cbs.update.length; ++i)\n        cbs.update[i](oldVnode, vnode);\n      vnode.data.hook?.update?.(oldVnode, vnode);\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        api.setTextContent(elm, \"\");\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      }\n      api.setTextContent(elm, vnode.text!);\n    }\n    hook?.postpatch?.(oldVnode, vnode);\n  }\n\n  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\n    let i: number, elm: Node, parent: Node;\n    const insertedVnodeQueue: VNodeQueue = [];\n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();\n\n    if (!isVnode(oldVnode)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      elm = oldVnode.elm!;\n      parent = api.parentNode(elm) as Node;\n\n      createElm(vnode, insertedVnodeQueue);\n\n      if (parent !== null) {\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\n    }\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();\n    return vnode;\n  };\n}\n</code></pre><h3 id=\"h\">h</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">import { vnode, VNode, VNodeData } from \"./vnode\";\nimport * as is from \"./is\";\n\nexport type VNodes = VNode[];\nexport type VNodeChildElement = VNode | string | number | undefined | null;\nexport type ArrayOrElement<T> = T | T[];\nexport type VNodeChildren = ArrayOrElement<VNodeChildElement>;\n\nfunction addNS(\n  data: any,\n  children: VNodes | undefined,\n  sel: string | undefined\n): void {\n  data.ns = \"http://www.w3.org/2000/svg\";\n  if (sel !== \"foreignObject\" && children !== undefined) {\n    for (let i = 0; i < children.length; ++i) {\n      const childData = children[i].data;\n      if (childData !== undefined) {\n        addNS(childData, children[i].children as VNodes, children[i].sel);\n      }\n    }\n  }\n}\n\nexport function h(sel: string): VNode;\nexport function h(sel: string, data: VNodeData | null): VNode;\nexport function h(sel: string, children: VNodeChildren): VNode;\nexport function h(\n  sel: string,\n  data: VNodeData | null,\n  children: VNodeChildren\n): VNode;\nexport function h(sel: any, b?: any, c?: any): VNode {\n  let data: VNodeData = {};\n  let children: any;\n  let text: any;\n  let i: number;\n  // c 不为空 可能是 [] / string\n  if (c !== undefined) {\n    // b 不为空 有 {} options (认为是 VNodeData)\n    if (b !== null) {\n      data = b;\n    }\n    // 如果 c 是 []\n    if (is.array(c)) {\n      children = c;\n    } else if (is.primitive(c)) { // c 是 string / number 应该认为是 text node\n      text = c;\n    } else if (c && c.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ c ]\n      children = [c];\n    }\n  } else if (b !== undefined && b !== null) { // 如果是 b 不为空\n    // 如果是 array 说明是 VNodeChildren\n    if (is.array(b)) {\n      children = b;\n    } else if (is.primitive(b)) { // 如果是 string/number 应该认为是 text node\n      text = b;\n    } else if (b && b.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ b ]\n      children = [b];\n    } else { // 认为 b 是 VNodeData\n      data = b;\n    }\n  }\n  // 如果存在 children\n  if (children !== undefined) {\n    for (i = 0; i < children.length; ++i) {\n      // 如果每个 children 是 string/number 转换成 vnode\n      if (is.primitive(children[i]))\n        children[i] = vnode(\n          undefined,\n          undefined,\n          undefined,\n          children[i],\n          undefined\n        );\n    }\n  }\n  // 如果是 svg 添加 namespace\n  if (\n    sel[0] === \"s\" &&\n    sel[1] === \"v\" &&\n    sel[2] === \"g\" &&\n    (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")\n  ) {\n    addNS(data, children, sel);\n  }\n  return vnode(sel, data, children, text, undefined);\n}</code></pre><h3 id=\"patch\">patch</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">// 调用 init 返回 patch  \n\n  function emptyNodeAt(elm: Element) {\n    const id = elm.id ? \"#\" + elm.id : \"\";\n\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n    const classes = elm.getAttribute(\"class\");\n\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n    // document.querySelector('div').tagName => DIV\n    // div#id.classa.classb / div#id / div.class / div\n    return vnode(\n      api.tagName(elm).toLowerCase() + id + c,\n      {},\n      [],\n      undefined,\n      elm\n    );\n  }\n\nreturn function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\n    let i: number, elm: Node, parent: Node;\n    const insertedVnodeQueue: VNodeQueue = [];\n      // 调用 module 中的 pre hook \n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();\n        \n      // 如果 oldVnode 是 Element 转换为空的 vnode\n    if (!isVnode(oldVnode)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n            \n       // > 如果相同，调用 patchVnode，如果不相同，会调用 createElm 来创建一个新的 dom 节点，然后如果存在父节点，便将其插入到 dom 上，然后移除旧的 dom 节点来完成更新。\n  \n      // oldVnode vnode sel key is 相同\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      elm = oldVnode.elm!;\n      // ele parentNode\n      parent = api.parentNode(elm) as Node;\n            // 创建\n      createElm(vnode, insertedVnodeQueue);\n            \n      // 有父节点\n      if (parent !== null) {\n        // insert dom\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\n        // remove vnode\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n        \n  // 调用元素上的 insert hook，insert  hook 在 module 上不支持\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\n    }\n      // 调用 module post hook\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();\n    return vnode;\n  };</code></pre><blockquote>\n<p>The following hooks are available for modules: <code>pre</code>, <code>create</code>, <code>update</code>, <code>destroy</code>, <code>remove</code>, <code>post</code></p>\n<p>The following hooks are available in the <code>hook</code> property of individual elements: <code>init</code>, <code>create</code>, <code>insert</code>, <code>prepatch</code>, <code>update</code>, <code>postpatch</code>, <code>destroy</code>, <code>remove</code>.</p>\n</blockquote>\n<h3 id=\"createelm\">createElm</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any;\n    let data = vnode.data;\n    // 调用元素的 init hook\n    if (data !== undefined) {\n      const init = data.hook?.init;\n      if (isDef(init)) {\n        init(vnode);\n        data = vnode.data;\n      }\n    }\n    const children = vnode.children;\n    \n    // 创建注释节点\n    const sel = vnode.sel;\n    if (sel === \"!\") {\n      if (isUndef(vnode.text)) {\n        vnode.text = \"\";\n      }\n      vnode.elm = api.createComment(vnode.text!);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf(\"#\");\n      const dotIdx = sel.indexOf(\".\", hashIdx);\n      // div#box\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\n      // div.boxclass\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\n      const tag =\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel;\n      const elm = (vnode.elm =\n        isDef(data) && isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data));\n      if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n      if (dotIdx > 0)\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n      // 调用 module 的 create hook\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      // 挂在子节点\n      if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        // 插入 文本节点\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      // 执行 vnode data hook\n      const hook = vnode.data!.hook;\n      if (isDef(hook)) {\n        // 执行 hook create\n        hook.create?.(emptyNode, vnode);\n        if (hook.insert) {\n          // insert hook 存储起来 等 dom 插入后才会调用，这里用个数组来保存能避免调用时再次对 vnode 树做遍历\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } else {\n      // 文本节点\n      vnode.elm = api.createTextNode(vnode.text!);\n    }\n    return vnode.elm;\n  }</code></pre><h3 id=\"patchvnode\">patchVnode</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">function patchVnode(\n    oldVnode: VNode,\n    vnode: VNode,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    const hook = vnode.data?.hook;\n    // 执行 prepatch hook\n    hook?.prepatch?.(oldVnode, vnode);\n    const elm = (vnode.elm = oldVnode.elm)!;\n    const oldCh = oldVnode.children as VNode[];\n    const ch = vnode.children as VNode[];\n     // 新 旧 vnode 相同\n    if (oldVnode === vnode) return;\n    // 执行 cbs update hook，vnode update hook\n    if (vnode.data !== undefined) {\n      for (let i = 0; i < cbs.update.length; ++i)\n        cbs.update[i](oldVnode, vnode);\n      vnode.data.hook?.update?.(oldVnode, vnode);\n    }\n    // 是没有定义的\n    if (isUndef(vnode.text)) {\n      // 均存在 children 且不相同，调用 updateChildren\n    \n      // 定义过 children\n      if (isDef(oldCh) && isDef(ch)) {\n        // old children 不等于 new children\n        // 更新 updateChildren\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      } else if (isDef(ch)) { // 只定义了 new children\n        // 新 vnode 存在 children，旧 vnode 不存在 children，如果旧 vnode 存在 text 先清空，然后调用 addVnodes\n        \n        // 如果是 text，设置内容\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\n        // 添加 vnode\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) { // 只定义 old children\n        // 新 vnode 不存在 children，旧 vnode 存在 children，调用 removeVnodes 移除 children\n        \n        // 移除 vnode\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) { // 只定义了 old vnode text\n        // 设置内容\n        api.setTextContent(elm, \"\");\n      }\n    } else if (oldVnode.text !== vnode.text) { // old vnode text 和 new vnode text 不一样\n      // 均不存在 children，新 vnode 不存在 text，移除旧 vnode 的 text\n      \n      // 如果定义了 old children\n      if (isDef(oldCh)) {\n        // 移除\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      }\n      // 均存在 text，更新 text\n      \n      // 设置新内容\n      api.setTextContent(elm, vnode.text!);\n    }\n    // 执行 postpatch hook\n    hook?.postpatch?.(oldVnode, vnode);\n  }</code></pre><h3 id=\"updatechildren\">updateChildren</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">  function updateChildren(\n    parentElm: Node,\n    oldCh: VNode[],\n    newCh: VNode[],\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    let oldStartIdx = 0; // 旧 头 索引\n    let newStartIdx = 0; // 新 头 索引\n    let oldEndIdx = oldCh.length - 1; // 旧 尾 索引\n    let oldStartVnode = oldCh[0]; // 旧 头 Vnode\n    let oldEndVnode = oldCh[oldEndIdx]; // 旧 尾 Vnode\n    let newEndIdx = newCh.length - 1; // 新 尾 索引\n    let newStartVnode = newCh[0]; // 新 头 Vnode\n    let newEndVnode = newCh[newEndIdx]; // 新 尾 Vnode\n    let oldKeyToIdx: KeyToIndexMap | undefined;\n    let idxInOld: number;\n    let elmToMove: VNode;\n    let before: any;\n\n    // 循环 从 头 到 尾 处理（新/旧）\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      // 如果 头尾（新/旧）其中有为 null 重新赋值，并且为元素数组中 添加/减少 一位\n      if (oldStartVnode == null) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n      } else if (oldEndVnode == null) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (newStartVnode == null) {\n        newStartVnode = newCh[++newStartIdx];\n      } else if (newEndVnode == null) {\n        newEndVnode = newCh[--newEndIdx];\n\n        // 如果相同 对比 新/旧 内容变化然后更新 DOM\n        // 新/旧 头Vnode 赋值\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n\n        // 节点移动到右边 更新 DOM\n        // 把更新的内容移动插入到旧节点最后\n        // 旧头索引 ++\n        // 新尾索引 --\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(\n          parentElm,\n          oldStartVnode.elm!,\n          api.nextSibling(oldEndVnode.elm!)\n        );\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n\n        // 节点移动到左边 更新 DOM\n        // 把更新的内容移动插入到旧节点最前\n        // 旧尾 --\n        // 新头 ++\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n\n\n        // 如果不是以上情况\n        // 开始节点是一个新节点\n        // 如果没有 key，创建 DOM 插入到前方\n        // 如果有 key，判断 sel 是否相同，如果不同创建 DOM 如果相同则代表是相同节点\n      } else {\n\n        // 方便通过新节点的key找到旧节点数组的索引\n        if (oldKeyToIdx === undefined) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        // 用新节点的key 找到老节点的索引\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\n\n        // 如果是新节点\n        if (isUndef(idxInOld)) {\n          // New element\n          api.insertBefore(\n            parentElm,\n            createElm(newStartVnode, insertedVnodeQueue),\n            oldStartVnode.elm!\n          );\n        } else {\n          // 旧节点\n          // 取出旧节点\n          elmToMove = oldCh[idxInOld];\n          // 新元素 直接创建一个新的插入\n          if (elmToMove.sel !== newStartVnode.sel) {\n            api.insertBefore(\n              parentElm,\n              createElm(newStartVnode, insertedVnodeQueue),\n              oldStartVnode.elm!\n            );\n          } else {\n            // 没有修改过 更新内部 DOM\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            // 把旧节点相应位置的元素设置为undefined\n            oldCh[idxInOld] = undefined as any;\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\n          }\n        }\n        // 插入完成后，索引增加\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    // 老节点 或 新节点遍历完成\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n      if (oldStartIdx > oldEndIdx) {\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(\n          parentElm,\n          before,\n          newCh,\n          newStartIdx,\n          newEndIdx,\n          insertedVnodeQueue\n        );\n      } else {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n  }</code></pre><h3 id=\"addvnodes\">addVnodes</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">  function addVnodes(\n    parentElm: Node,\n    before: Node | null,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n      }\n    }\n  }</code></pre><h3 id=\"removevnodes\">removeVnodes</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">\n  function removeVnodes(\n    parentElm: Node,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number\n  ): void {\n    for (; startIdx <= endIdx; ++startIdx) {\n      let listeners: number;\n      let rm: () => void;\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        if (isDef(ch.sel)) {\n          // ˙执行 ch data destroy hook\n          invokeDestroyHook(ch);\n          listeners = cbs.remove.length + 1;\n          rm = createRmCb(ch.elm!, listeners);\n          // 调用 module 中是 remove hook\n          for (let i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);\n           // 调用 vnode 的 remove hook\n          const removeHook = ch?.data?.hook?.remove;\n          if (isDef(removeHook)) {\n            removeHook(ch, rm);\n          } else {\n            rm();\n          }\n        } else {\n          // Text node\n          api.removeChild(parentElm, ch.elm!);\n        }\n      }\n    }\n  }\n\n// 调用 destroy hook\nfunction invokeDestroyHook(vnode: VNode) {\n  const data = vnode.data;\n  if (data !== undefined) {\n    data?.hook?.destroy?.(vnode);\n    for (let i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n    if (vnode.children !== undefined) {\n      for (let j = 0; j < vnode.children.length; ++j) {\n        const child = vnode.children[j];\n        if (child != null && typeof child !== \"string\") {\n          invokeDestroyHook(child);\n        }\n      }\n    }\n  }\n}\n\n\nfunction createRmCb(childElm: Node, listeners: number) {\n  return function rmCb() {\n    if (--listeners === 0) {\n      const parent = api.parentNode(childElm) as Node;\n      api.removeChild(parent, childElm);\n    }\n  };\n}</code></pre><h3 id=\"createelm-1\">createElm</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any;\n    let data = vnode.data;\n    if (data !== undefined) {\n      // 调用 init hook\n      const init = data.hook?.init;\n      if (isDef(init)) {\n        init(vnode);\n        data = vnode.data;\n      }\n    }\n    const children = vnode.children;\n    const sel = vnode.sel;\n    if (sel === \"!\") { // 注释\n      if (isUndef(vnode.text)) {\n        vnode.text = \"\";\n      }\n      vnode.elm = api.createComment(vnode.text!);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf(\"#\");\n      const dotIdx = sel.indexOf(\".\", hashIdx);\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\n      const tag =\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel;\n      const elm = (vnode.elm =\n        isDef(data) && isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data));\n      if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n      if (dotIdx > 0)\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      // 调用 create hook\n      const hook = vnode.data!.hook;\n      if (isDef(hook)) {\n        hook.create?.(emptyNode, vnode);\n        if (hook.insert) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } else {\n      vnode.elm = api.createTextNode(vnode.text!);\n    }\n    return vnode.elm;\n  }</code></pre><h3 id=\"thunk\">thunk</h3>\n<pre class=\"language-typescript\"><code class=\"language-typescript\">export interface ThunkData extends VNodeData {\n  fn: () => VNode;\n  args: any[];\n}\n\nexport interface Thunk extends VNode {\n  data: ThunkData;\n}\n\nexport interface ThunkFn {\n  (sel: string, fn: (...args: any[]) => any, args: any[]): Thunk;\n  (sel: string, key: any, fn: (...args: any[]) => any, args: any[]): Thunk;\n}\n\n// thunk  fn 、 args 属性保存到 vnode 上，在 prepatch 时需要进行比较\n// 将 vnode 上的数据拷贝到 thunk 上， patchVnode 中判断，相同会结束 patchVnode\nfunction copyToThunk(vnode: VNode, thunk: VNode): void {\n  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;\n  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;\n  thunk.data = vnode.data;\n  thunk.children = vnode.children;\n  thunk.text = vnode.text;\n  thunk.elm = vnode.elm;\n}\n\nfunction init(thunk: VNode): void {\n  const cur = thunk.data as VNodeData;\n  const vnode = (cur.fn as any)(...cur.args!);\n  copyToThunk(vnode, thunk);\n}\n\nfunction prepatch(oldVnode: VNode, thunk: VNode): void {\n  let i: number;\n  const old = oldVnode.data as VNodeData;\n  const cur = thunk.data as VNodeData;\n  const oldArgs = old.args;\n  const args = cur.args;\n  //  如果 fn 不同或 args 长度不同，说明发生了变化，调用 fn 生成新的 vnode 并返回\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\n    copyToThunk((cur.fn as any)(...args!), thunk);\n    return;\n  }\n  // 如果每个参数发生变化，逻辑同上\n  for (i = 0; i < (args as any).length; ++i) {\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\n      copyToThunk((cur.fn as any)(...args!), thunk);\n      return;\n    }\n  }\n  copyToThunk(oldVnode, thunk);\n}\n// 使用 h 返回 vnode\n// 添加 init prepatch hook\nexport const thunk = function thunk(\n  sel: string,\n  key?: any,\n  fn?: any,\n  args?: any\n): VNode {\n  if (args === undefined) {\n    args = fn;\n    fn = key;\n    key = undefined;\n  }\n  return h(sel, {\n    key: key,\n    hook: { init, prepatch },\n    fn: fn,\n    args: args,\n  });\n} as ThunkFn;\n</code></pre>","attributes":{}},"themeConfig":{"title":"Blog(issues)","links":[{"title":"GitHub","url":"https://github.com/xiaotiandada/blog"},{"title":"Twitter","url":"https://twitter.com/XiaoTianIsMe"}]}},"__N_SSG":true}